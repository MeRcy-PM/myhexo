{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.234bc0.css","path":"main.234bc0.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.d238ee.js","path":"mobile.d238ee.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.885efe.js","path":"slider.885efe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.234bc0.js","path":"main.234bc0.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1491487001000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1491487001000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1491487001000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1491487001000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1491487001000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1491487001000},{"_id":"themes/yilia/_config.yml","hash":"0aff6ef21428969c513924885be018190af2e4ca","modified":1491487001000},{"_id":"themes/yilia/package.json","hash":"946b26ae0dff42c590068f0a58ecd326ed059b68","modified":1491487001000},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1491487001000},{"_id":"themes/yilia/webpack.config.js","hash":"c4dca5c60822c90359e48fad373be768ae9fb43d","modified":1491487001000},{"_id":"source/_posts/QUIC翻译.md","hash":"d3971ff42ccd7e81efe92295e2be3938ced3e376","modified":1491487001000},{"_id":"source/_posts/hello-world.md","hash":"3f188c80173e36cd20d1901a58d445de8b338787","modified":1491487001000},{"_id":"source/_posts/TCP的FRTO分析.md","hash":"8573e7296601fd04e150c8049d690687b0e51ee4","modified":1494469711000},{"_id":"source/_posts/TCP简介-读书笔记.md","hash":"d32d877a9a1e6bd499c84aabde68db034cf9e6f8","modified":1491487001000},{"_id":"source/_posts/webrtc中rtcp码率控制分析.md","hash":"463b17b707c8a973c646439b65430b8a7e96aaff","modified":1494300423000},{"_id":"source/_posts/九层妖塔.md","hash":"7753a0417bc78f26e902cb476f4a821afb605433","modified":1491487001000},{"_id":"source/about/index.md","hash":"ce9052d7438d93a2a46159366c6fb701d2a5d220","modified":1491487001000},{"_id":"source/_posts/linux内核慢启动拥塞避免代码分析.md","hash":"86e7a7bcd61fe97eb8e5e0c33c01bef5b2262187","modified":1494469779000},{"_id":"source/articles/index.md","hash":"1a3e38034eca6672a4e00cafb12e21b2543f7d09","modified":1491487001000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1491487001000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1491487001000},{"_id":"themes/yilia/.git/index","hash":"7281e4a31a9abcd383b17c905e68ee33a56a54c4","modified":1491487039000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1491487001000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1491487001000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1491487001000},{"_id":"themes/yilia/.git/packed-refs","hash":"144a02fde3eaced071755091d413698cb7e8382d","modified":1491487001000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1491487001000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1491487001000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1491487001000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1491487001000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1491487001000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1491487001000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1491487001000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1491487001000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1491487001000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1491487001000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1491487001000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1491487001000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1491487001000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1491487001000},{"_id":"themes/yilia/source/main.234bc0.css","hash":"b9f93c2b98c7f060dd6cbea5f919d705f19bb0a0","modified":1491487001000},{"_id":"themes/yilia/source/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1491487001000},{"_id":"themes/yilia/source/slider.885efe.js","hash":"1f1a6548c6016cc132bf65a1701cc8421a1f8414","modified":1491487001000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1491487001000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1491487001000},{"_id":"themes/yilia/source/main.234bc0.js","hash":"988c141a741441812bcf4c408ef530d7a01522f3","modified":1491487001000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1491487001000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1491487001000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1491487001000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1491487001000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1491487001000},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1491487001000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1491487001000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"51f59729316621322d7288059e08e3832d5996d7","modified":1491487001000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1491487001000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"491d8c45a863fb66118df7ba6d9b4bc2fa43621c","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"a8e6c5fd0551009e6a66754a18a992a0eabc0b6a","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"1b91850e8708ce4c83e3cc3f474921182d792308","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"f5e98b6013c968afb867626ed6617cd1cedc3d3a","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"c4a0f16d554e7e7007856d45b78443d7bf0b40b7","modified":1491487001000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"17be4f27eb8951835c29dafd0f6ba1b18e47cc6b","modified":1491487001000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1491487001000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1491487001000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1491487001000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1491487001000},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1491487001000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1491487001000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1491487001000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1491487001000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1491487001000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1491487001000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1491487001000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"b750499d5120f963b683d0c96ac3f345c714e448","modified":1491487001000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1491487001000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"ce24ab7049be634c17a163e2db39f1f0b1f7c119","modified":1491487001000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1491487001000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1491487001000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"b68772aa2b47d0ed89ce95d4e9d3d27931fe885c","modified":1491487001000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1491487001000},{"_id":"themes/yilia/source-src/css/duoshuo.scss","hash":"5e3feefbbba70d8da0ec2c75db41762dd4762a81","modified":1491487001000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1491487001000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1491487001000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1491487001000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"40c055e8360973a75db7c13f3280a4f465f9e5e3","modified":1491487001000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0ce6345a86c44e3fea5a4aa439614541112538f3","modified":1491487001000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1491487001000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"12abb65289eed5391d657b963a20f96a473b1cbd","modified":1491487001000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1491487001000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1491487001000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1491487001000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1491487001000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1491487001000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1491487001000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1491487001000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1491487001000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"61917c928d09783a3bc8a91503a59ab3a8696e90","modified":1491487001000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1491487001000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1491487001000},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1491487001000},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1491487001000},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1491487001000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1491487001000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1491487001000},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1491487001000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1491487001000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1491487001000},{"_id":"themes/yilia/.git/objects/pack/pack-7cbda1a00de83cde49bfab56b11029c9d89eaeba.idx","hash":"a61b8f72c229073a53ea75276b885df11940a11a","modified":1491487001000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"ec274ad8176ea701ec280f2352a47451b498c39a","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1491487001000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1491487001000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1491487001000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1491487001000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1491487001000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1491487001000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1491487001000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1491487001000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1491487001000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1491487001000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1491487001000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1491487001000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1491487001000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1491487001000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"51f59729316621322d7288059e08e3832d5996d7","modified":1491487001000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1491487001000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"51f59729316621322d7288059e08e3832d5996d7","modified":1491487001000},{"_id":"themes/yilia/.git/objects/pack/pack-7cbda1a00de83cde49bfab56b11029c9d89eaeba.pack","hash":"20c4b1f9c67efe010d0ae13728a02a3bb7d29a84","modified":1491487001000},{"_id":"public/content.json","hash":"104876d364fd76c16b17fc109ab9e5df67c0908e","modified":1494469809476},{"_id":"public/about/index.html","hash":"2ff03a92ac3d2001dacbd7abcd68e7b900346ac8","modified":1494300241223},{"_id":"public/articles/index.html","hash":"d3349c40356fa13eef57baf77b1d2ba236031b1d","modified":1494300241245},{"_id":"public/2017/04/11/TCP的FRTO分析/index.html","hash":"f17d5438f872a1e788535dc25a030e27829d11c8","modified":1494469809650},{"_id":"public/2017/04/06/hello-world/index.html","hash":"f04cbbfb67fb82140510cd731cad91b3b62e4683","modified":1494300241246},{"_id":"public/2017/03/27/linux内核慢启动拥塞避免代码分析/index.html","hash":"ac1abf1fb6672bc4fad4f9a9b098e0c04a7c67f1","modified":1494469809651},{"_id":"public/2017/03/19/TCP简介-读书笔记/index.html","hash":"f5edadfb9a56437489dcf88f77ca1f7694f45e0e","modified":1494300241246},{"_id":"public/2017/03/19/九层妖塔/index.html","hash":"686e2aa52bd07065dbb55122600d0c4dc7958de5","modified":1494300241246},{"_id":"public/archives/index.html","hash":"b2db0b4922f9792edb86d11608d8f605f27d4d75","modified":1494300241246},{"_id":"public/2017/04/02/QUIC翻译/index.html","hash":"afff28cc966f2618421e92d1e9c4be4405ed904e","modified":1494300241246},{"_id":"public/index.html","hash":"405306bd4bfcf509500cb7c243e823f607f084a6","modified":1494469809650},{"_id":"public/archives/2017/index.html","hash":"4fef239c29514b488ad0c8da39be2495b27bfa86","modified":1494300241246},{"_id":"public/archives/2017/04/index.html","hash":"5afdf9263a9eb1ec02e68b49184bb809a6d13f7a","modified":1494300241246},{"_id":"public/archives/2017/03/index.html","hash":"2aaaf33ca3087387737e186c6129e0be4571354b","modified":1494300241246},{"_id":"public/tags/传输协议/index.html","hash":"87ecde1fac3ab2e3e0702c8c72e5bad3ad9c420c","modified":1494300241246},{"_id":"public/tags/QUIC/index.html","hash":"cb9168b1d917e36d89d24aa11500bb0da9606370","modified":1494300241246},{"_id":"public/tags/linux/index.html","hash":"9474aa46c188b119fbba72517ed04069397f538b","modified":1494300241246},{"_id":"public/tags/TCP/index.html","hash":"d83734e30d12f19605695d6eeb33d68098ea8912","modified":1494300241246},{"_id":"public/tags/拥塞控制/index.html","hash":"ef3789db8f341cb1b641c3f619b3d046e174a895","modified":1494300241247},{"_id":"public/tags/读书笔记/index.html","hash":"9e7effc470442327b743eee970929e6c153a1178","modified":1494300241247},{"_id":"public/tags/涛哥说的都怼/index.html","hash":"87082de7bce6c7f2d6a54bd49bcb6963a1142ea9","modified":1494300241247},{"_id":"public/tags/fun/index.html","hash":"adf871c6c17c5d53592882fe053a2e5c68066b91","modified":1494300241247},{"_id":"public/2017/05/09/webrtc中rtcp码率控制分析/index.html","hash":"7e67a0396f48e58751996198de64c136dc23cf5c","modified":1494300427036},{"_id":"public/archives/2017/05/index.html","hash":"b44bd863d703879776674fb0f45a2f8769057196","modified":1494300241251},{"_id":"public/tags/webrt/index.html","hash":"3f517f27dffd869086fe2f518953860c11cc60b0","modified":1494300241251},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1494300241256},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1494300241256},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1494300241257},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1494300241257},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1494300241257},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1494300241257},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1494300241257},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1494300241257},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1494300241257},{"_id":"public/main.234bc0.css","hash":"b9f93c2b98c7f060dd6cbea5f919d705f19bb0a0","modified":1494300241260},{"_id":"public/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1494300241261},{"_id":"public/slider.885efe.js","hash":"1f1a6548c6016cc132bf65a1701cc8421a1f8414","modified":1494300241264},{"_id":"public/main.234bc0.js","hash":"988c141a741441812bcf4c408ef530d7a01522f3","modified":1494300241264}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-03-28T11:54:58.000Z","_content":"\n下岗职工，兴趣系统级别工程。看过一些代码，写过一些代码，学过一些语言(除了英语)。\n\n[Git](https://github.com/MeRcy-PM)\n[CSDN](http://blog.csdn.net/mercy_pm)\n\n联系方式: 240560351@qq.com\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/纳尔逊黑.jpg)\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-03-28 19:54:58\n---\n\n下岗职工，兴趣系统级别工程。看过一些代码，写过一些代码，学过一些语言(除了英语)。\n\n[Git](https://github.com/MeRcy-PM)\n[CSDN](http://blog.csdn.net/mercy_pm)\n\n联系方式: 240560351@qq.com\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/纳尔逊黑.jpg)\n","updated":"2017-04-06T13:56:41.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj2gzs4jf0001r8c3bc4cgl68","content":"<p>下岗职工，兴趣系统级别工程。看过一些代码，写过一些代码，学过一些语言(除了英语)。</p>\n<p><a href=\"https://github.com/MeRcy-PM\" target=\"_blank\" rel=\"external\">Git</a><br><a href=\"http://blog.csdn.net/mercy_pm\" target=\"_blank\" rel=\"external\">CSDN</a></p>\n<p>联系方式: 240560351@qq.com</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/纳尔逊黑.jpg\" alt=\"\"></p>\n","excerpt":"","more":"<p>下岗职工，兴趣系统级别工程。看过一些代码，写过一些代码，学过一些语言(除了英语)。</p>\n<p><a href=\"https://github.com/MeRcy-PM\">Git</a><br><a href=\"http://blog.csdn.net/mercy_pm\">CSDN</a></p>\n<p>联系方式: 240560351@qq.com</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/纳尔逊黑.jpg\" alt=\"\"></p>\n"},{"title":"Articles","date":"2017-03-28T04:32:32.000Z","_content":"","source":"articles/index.md","raw":"---\ntitle: Articles\ndate: 2017-03-28 12:32:32\n---\n","updated":"2017-04-06T13:56:41.000Z","path":"articles/index.html","comments":1,"layout":"page","_id":"cj2gzs4jl0003r8c3sgyx44sj","content":"","excerpt":"","more":""}],"Post":[{"title":"QUIC翻译","date":"2017-04-02T02:57:50.000Z","_content":"\n# QUIC中文翻译\n\n[翻译地址](https://github.com/MeRcy-PM/translation/blob/master/QUIC.md)\n\n翻译过程一些心路历程:\n\n距离上次完整翻译一篇文章已经好几年了，那还是本科毕设用的文章翻译，那时候还能用谷歌翻译，现在也又能了..........\n\n- 词汇量还是太差。。\n\n- 对于翻译，并不用把每句话都翻译出来，整段话意思一致就可以了。\n\n- 对于某些名词，也不需要完完全全翻译。\n","source":"_posts/QUIC翻译.md","raw":"---\ntitle: QUIC翻译\ndate: 2017-04-02 10:57:50\ntags: [QUIC, 传输协议]\n---\n\n# QUIC中文翻译\n\n[翻译地址](https://github.com/MeRcy-PM/translation/blob/master/QUIC.md)\n\n翻译过程一些心路历程:\n\n距离上次完整翻译一篇文章已经好几年了，那还是本科毕设用的文章翻译，那时候还能用谷歌翻译，现在也又能了..........\n\n- 词汇量还是太差。。\n\n- 对于翻译，并不用把每句话都翻译出来，整段话意思一致就可以了。\n\n- 对于某些名词，也不需要完完全全翻译。\n","slug":"QUIC翻译","published":1,"updated":"2017-04-06T13:56:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gzs4jb0000r8c3adjey83v","content":"<h1 id=\"QUIC中文翻译\"><a href=\"#QUIC中文翻译\" class=\"headerlink\" title=\"QUIC中文翻译\"></a>QUIC中文翻译</h1><p><a href=\"https://github.com/MeRcy-PM/translation/blob/master/QUIC.md\" target=\"_blank\" rel=\"external\">翻译地址</a></p>\n<p>翻译过程一些心路历程:</p>\n<p>距离上次完整翻译一篇文章已经好几年了，那还是本科毕设用的文章翻译，那时候还能用谷歌翻译，现在也又能了……….</p>\n<ul>\n<li><p>词汇量还是太差。。</p>\n</li>\n<li><p>对于翻译，并不用把每句话都翻译出来，整段话意思一致就可以了。</p>\n</li>\n<li><p>对于某些名词，也不需要完完全全翻译。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"QUIC中文翻译\"><a href=\"#QUIC中文翻译\" class=\"headerlink\" title=\"QUIC中文翻译\"></a>QUIC中文翻译</h1><p><a href=\"https://github.com/MeRcy-PM/translation/blob/master/QUIC.md\">翻译地址</a></p>\n<p>翻译过程一些心路历程:</p>\n<p>距离上次完整翻译一篇文章已经好几年了，那还是本科毕设用的文章翻译，那时候还能用谷歌翻译，现在也又能了……….</p>\n<ul>\n<li><p>词汇量还是太差。。</p>\n</li>\n<li><p>对于翻译，并不用把每句话都翻译出来，整段话意思一致就可以了。</p>\n</li>\n<li><p>对于某些名词，也不需要完完全全翻译。</p>\n</li>\n</ul>\n"},{"title":"小怼的世界","_content":"\n### 先打(怼)个(下)招(涛)呼(哥)吧\n\n[小刘](https://algebra84.github.io/2017/03/17/second/)，出来接客了.......\n\n### 为什么要写博客\n\n我：涛哥我考你一考，你有博客吗\n涛：不能写罢？……我教给你，记着！这些博客应该记着。将来做架构师的时候，写ppt要用。\n我：谁要你教，不就写博客么？\n涛：对呀对呀！……博客有四种写法，你知道么？\n我愈不耐烦了，努着嘴走远。\n涛哥见我毫不热心，便又叹一口气，显出极惋惜的样子。\n\n### 真Verson 2.0-beta\n\n[建立个人知识体系](https://zhuanlan.zhihu.com/p/25002816)\n\n初看一些东西，会觉得这个东西可能很简单，但是被人问及后，可能会在很多细节上出现很多漏洞。\n写博客可以在细节上进行思考，完善自己的知识体系。\n\n### 写些什么呢\n- 想到啥写啥吧\n","source":"_posts/hello-world.md","raw":"---\ntitle: 小怼的世界\n---\n\n### 先打(怼)个(下)招(涛)呼(哥)吧\n\n[小刘](https://algebra84.github.io/2017/03/17/second/)，出来接客了.......\n\n### 为什么要写博客\n\n我：涛哥我考你一考，你有博客吗\n涛：不能写罢？……我教给你，记着！这些博客应该记着。将来做架构师的时候，写ppt要用。\n我：谁要你教，不就写博客么？\n涛：对呀对呀！……博客有四种写法，你知道么？\n我愈不耐烦了，努着嘴走远。\n涛哥见我毫不热心，便又叹一口气，显出极惋惜的样子。\n\n### 真Verson 2.0-beta\n\n[建立个人知识体系](https://zhuanlan.zhihu.com/p/25002816)\n\n初看一些东西，会觉得这个东西可能很简单，但是被人问及后，可能会在很多细节上出现很多漏洞。\n写博客可以在细节上进行思考，完善自己的知识体系。\n\n### 写些什么呢\n- 想到啥写啥吧\n","slug":"hello-world","published":1,"date":"2017-04-06T13:56:41.000Z","updated":"2017-04-06T13:56:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gzs4jj0002r8c3tlzcmrlw","content":"<h3 id=\"先打-怼-个-下-招-涛-呼-哥-吧\"><a href=\"#先打-怼-个-下-招-涛-呼-哥-吧\" class=\"headerlink\" title=\"先打(怼)个(下)招(涛)呼(哥)吧\"></a>先打(怼)个(下)招(涛)呼(哥)吧</h3><p><a href=\"https://algebra84.github.io/2017/03/17/second/\" target=\"_blank\" rel=\"external\">小刘</a>，出来接客了…….</p>\n<h3 id=\"为什么要写博客\"><a href=\"#为什么要写博客\" class=\"headerlink\" title=\"为什么要写博客\"></a>为什么要写博客</h3><p>我：涛哥我考你一考，你有博客吗<br>涛：不能写罢？……我教给你，记着！这些博客应该记着。将来做架构师的时候，写ppt要用。<br>我：谁要你教，不就写博客么？<br>涛：对呀对呀！……博客有四种写法，你知道么？<br>我愈不耐烦了，努着嘴走远。<br>涛哥见我毫不热心，便又叹一口气，显出极惋惜的样子。</p>\n<h3 id=\"真Verson-2-0-beta\"><a href=\"#真Verson-2-0-beta\" class=\"headerlink\" title=\"真Verson 2.0-beta\"></a>真Verson 2.0-beta</h3><p><a href=\"https://zhuanlan.zhihu.com/p/25002816\" target=\"_blank\" rel=\"external\">建立个人知识体系</a></p>\n<p>初看一些东西，会觉得这个东西可能很简单，但是被人问及后，可能会在很多细节上出现很多漏洞。<br>写博客可以在细节上进行思考，完善自己的知识体系。</p>\n<h3 id=\"写些什么呢\"><a href=\"#写些什么呢\" class=\"headerlink\" title=\"写些什么呢\"></a>写些什么呢</h3><ul>\n<li>想到啥写啥吧</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"先打-怼-个-下-招-涛-呼-哥-吧\"><a href=\"#先打-怼-个-下-招-涛-呼-哥-吧\" class=\"headerlink\" title=\"先打(怼)个(下)招(涛)呼(哥)吧\"></a>先打(怼)个(下)招(涛)呼(哥)吧</h3><p><a href=\"https://algebra84.github.io/2017/03/17/second/\">小刘</a>，出来接客了…….</p>\n<h3 id=\"为什么要写博客\"><a href=\"#为什么要写博客\" class=\"headerlink\" title=\"为什么要写博客\"></a>为什么要写博客</h3><p>我：涛哥我考你一考，你有博客吗<br>涛：不能写罢？……我教给你，记着！这些博客应该记着。将来做架构师的时候，写ppt要用。<br>我：谁要你教，不就写博客么？<br>涛：对呀对呀！……博客有四种写法，你知道么？<br>我愈不耐烦了，努着嘴走远。<br>涛哥见我毫不热心，便又叹一口气，显出极惋惜的样子。</p>\n<h3 id=\"真Verson-2-0-beta\"><a href=\"#真Verson-2-0-beta\" class=\"headerlink\" title=\"真Verson 2.0-beta\"></a>真Verson 2.0-beta</h3><p><a href=\"https://zhuanlan.zhihu.com/p/25002816\">建立个人知识体系</a></p>\n<p>初看一些东西，会觉得这个东西可能很简单，但是被人问及后，可能会在很多细节上出现很多漏洞。<br>写博客可以在细节上进行思考，完善自己的知识体系。</p>\n<h3 id=\"写些什么呢\"><a href=\"#写些什么呢\" class=\"headerlink\" title=\"写些什么呢\"></a>写些什么呢</h3><ul>\n<li>想到啥写啥吧</li>\n</ul>\n"},{"title":"TCP的FRTO分析","date":"2017-04-11T11:04:12.000Z","_content":"\n# TCP的FRTO理解\n\n本文主要描述内核4.9.4中的TCP丢包处理与frto相关的操作，主要覆盖使用sack的场景。\n\n# 0. 参考文档\n[1] [RFC-5682](https://tools.ietf.org/html/rfc5682#section-3.1)\n[2] [linuxtcp.ps](https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz)\n[3] [frto.pdf](http://www.sarolahti.fi/pasi/papers/frto-ccr.pdf)\n\n# 1. FRTO要解决的问题\nFRTO主要是用来处理在DSACK生效时，突发的延迟触发RTO超时后，不必要的延迟和重传报文的ack造成了DSACK而产生非必要的快速重传[1]。\n传统的基于DSACK的RTO超时会有如下问题:\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/conventional.png)\n\n- 1) 在16.5s和17s中间最后一个ack到来之前一直处于慢启动阶段，指数发送数据，\n- 2) 18s虚假RTO触发，其实只是延迟，但是这时候RTO工作，重传丢失的报文。\n- 3) 19s的时候延迟包的ack到达，注意到此时ack的数据序列号是大于重传报文的序列号。\n- 4) 延迟的ack使发送端继续重传之后延迟的ack之后的数据(这部分数据之前已经发送过))(19s到19.5s之间的重传)。\n- 5) 在19.8s，之前发送的最大序列号报文被确认，接着由于4中的重传报文陆续到达，接收端发送了一系列以最大序列号报文为ack的Duplicate SACK。\n- 6) 发送端收到这些重复的DSACK后，触发了快速重传，降低了传输性能。\n\n使用FRTO后的效果:\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/frto.png)\n\n- 1) 同上\n- 2) 同上\n- 3) 同上\n- 4) 由于延迟包的ack更新了snd_una，因此这里不重传其余数据，而是发送两个新的分片。\n- 5) 延迟包的ack陆续到达，此时由于未重传的包收到了对应的ack，因此可以判断当前是一个虚假的RTO，继续发送新的数据。\n\n# 1. FRTO rfc解释\n这里主要针对sack的场景，即rfc-5682的section 3。\n\n```\n   1) When the retransmission timer expires, retransmit the first\n      unacknowledged segment and set SpuriousRecovery to FALSE.\n      Following the recommendation in the SACK specification [MMFR96],\n      reset the SACK scoreboard.  If \"RecoveryPoint\" is larger than or\n      equal to SND.UNA, do not enter step 2 of this algorithm.  Instead,\n      set variable \"RecoveryPoint\" to indicate the highest sequence\n      number transmitted so far and continue with slow-start\n      retransmissions following the conventional RTO recovery algorithm.\n\n   2) Wait until the acknowledgment of the data retransmitted due to the\n      timeout arrives at the sender.  If duplicate ACKs arrive before\n      the cumulative acknowledgment for retransmitted data, adjust the\n      scoreboard according to the incoming SACK information.  Stay in\n      step 2 and wait for the next new acknowledgment.  If the\n      retransmission timeout expires again, go to step 1 of the\n      algorithm.  When a new acknowledgment arrives, set variable\n      \"RecoveryPoint\" to indicate the highest sequence number\n      transmitted so far.\n\n      a) If the Cumulative Acknowledgment field covers \"RecoveryPoint\"\n         but not more than \"RecoveryPoint\", revert to the conventional\n         RTO recovery and set the congestion window to no more than 2 *\n         MSS, like a regular TCP would do.  Do not enter step 3 of this\n         algorithm.\n\n      b) Else, if the Cumulative Acknowledgment field does not cover\n         \"RecoveryPoint\" but is larger than SND.UNA, transmit up to two\n         new (previously unsent) segments and proceed to step 3.  If the\n         TCP sender is not able to transmit any previously unsent data\n         -- either due to receiver window limitation or because it does\n         not have any new data to send -- the recommended action is to\n         refrain from entering step 3 of this algorithm.  Rather,\n         continue with slow-start retransmissions following the\n         conventional RTO recovery algorithm.\n\n         It is also possible to apply some of the alternatives for\n         handling window-limited cases discussed in Appendix A.\n\n   3) The next acknowledgment arrives at the sender.  Either a duplicate\n      ACK or a new cumulative ACK (advancing the window) applies in this\n      step.  Other types of ACKs are ignored without any action.\n\n      a) If the Cumulative Acknowledgment field or the SACK information\n         covers more than \"RecoveryPoint\", set the congestion window to\n         no more than 3 * MSS and proceed with the conventional RTO\n         recovery, retransmitting unacknowledged segments.  Take this\n         branch also when the acknowledgment is a duplicate ACK and it\n         does not acknowledge any new, previously unacknowledged data\n         below \"RecoveryPoint\" in the SACK information.  Leave\n         SpuriousRecovery set to FALSE.\n\n      b) If the Cumulative Acknowledgment field or a SACK information in\n         the ACK does not cover more than \"RecoveryPoint\" AND it\n         acknowledges data that was not acknowledged earlier (either\n         with cumulative acknowledgment or using SACK information),\n         declare the timeout spurious and set SpuriousRecovery to\n         SPUR_TO.  The retransmission timeout can be declared spurious,\n         because the segment acknowledged with this ACK was transmitted\n         before the timeout.\n```\n\n注1: RecoveryPoint为tcp中的high_seq，后称恢复点。\n注2: snd_nxt为下一个将要发送的包的包号。\n- 3.1:  当重传定时器超时了，首先重传第一个未确认的分片，同时设置SpuriousRecovery为false，并重置sack的计分板。\n如果恢复点大于等于下一个要发的包(好像基本不可能，最多等于)，则将恢复点设置为当前发送的最大包。进入常规恢复。否则进入step 2。\n- 3.2: 等待重传数据的ack到来。如果重复的ack比新的ack更早到达，则更新相应的sack计分板，同时留在第二步，等待新的ack到来。如果重传定时器再次超时，回到第一步。当新的ack到来后，更新恢复点。\n\t- a) 如果到来的ack中包括了恢复点，但不超过恢复点，撤销至普通恢复，同时拥塞窗口设置不大于2倍MSS。不进入第三步。\n\t- b) 如果到来的ack中不包含恢复点，但是收到的包超过未确认包，发送两个新的分片，并进入步骤3。如果当前发送端无法发送新报文(接收窗口限制或者没有新的应用层数据)，这里建议不要进入步骤3，而是使用恢复步骤。\n-3.3: 下一个ack到来，除了新的ack或者是重复ack，其他ack在这个步骤中都被忽略。\n\t- a) 如果新的ack包含了恢复点，则设置拥塞窗口不超过3倍MSS大小并执行恢复操作，重传未确认分片。这个分支也处理重复ack但是没有确认任何新块的场景。\n\t- b) 如果新的ack或者sack信息中没有包含恢复点，且确认的数据是之前没有确认的，则认为这个超时是一个奇怪的超时，并设置SpuriousRecovery为SPUR_TO。这个重传被标记为奇怪的，因为这个分片在超时前被确认了。\n\n其实论文中的图比rfc这段(恢复点的几个判断理解费力。。)更好理解，也更契合代码，为了识别出虚假的RTO：\n- 超时后先只重发丢失的一个包(3.1)。\n- 判断重传后的第一个新的ack是否更新了snd\\_una，如果更新了snd\\_una，就发送新的数据，在判断虚假RTO之前不重传数据(3.2.b)\n- 如果没重传就已经收到数据，尝试撤销本次RTO，如果撤销成功，这就是一个虚假RTO，进入恢复流程(3.3.b)。如果还是重复ack，则认为这是一个丢包事件(3.3.a)。\n\n# 2. 4.9.4中的代码\n这里主要分析tcp\\_process\\_loss函数。\n\n```cpp\n/* Process an ACK in CA_Loss state. Move to CA_Open if lost data are\n * recovered or spurious. Otherwise retransmits more on partial ACKs.\n */\n// 这个函数中如果可以恢复，则会直接进入CA_OPEN。\n// 不进入CA_OPEN则会直接返回tcp_ack中进行重传(或者是发送新分片)。\nstatic void tcp_process_loss(struct sock *sk, int flag, bool is_dupack,\n\t\t\t     int *rexmit)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t// 完全恢复\n\tbool recovered = !before(tp->snd_una, tp->high_seq);\n\n\t// 最大的未确认包已经发生改变，可能是之前丢包已经恢复，尝试撤销丢包状态。\n\t// 当frto关闭时，这是唯二可以退出LOSS状态的条件。\n\tif ((flag & FLAG_SND_UNA_ADVANCED) &&\n\t    tcp_try_undo_loss(sk, false))\n\t\treturn;\n\n\t// frto在enter_loss时候置位，根据超时时的设置决定是否可能是一个虚假的RTO。\n\tif (tp->frto) { /* F-RTO RFC5682 sec 3.1 (sack enhanced version). */\n\t\t/* Step 3.b. A timeout is spurious if not all data are\n\t\t * lost, i.e., never-retransmitted data are (s)acked.\n\t\t */\n\t\t// #define FLAG_ORIG_SACK_ACKED\t0x200 /* Never retransmitted data are (s)acked\t*/\n\t\t// 包没有丢，因为还没重传就收到了ACK，只是延迟了，这是虚假RTO，撤销丢包状态。\n\t\t// 注: 这里的frto_undo传参为true，必定恢复。\n\t\t// 对应RTO论文图中的延迟包的acks。\n\t\tif ((flag & FLAG_ORIG_SACK_ACKED) &&\n\t\t    tcp_try_undo_loss(sk, true))\n\t\t\treturn;\n\n\t\tif (after(tp->snd_nxt, tp->high_seq)) {\n\t\t\t// 如果是刚进入LOSS状态，会先尝试重传，这时候snd_nxt总是等于high_seq的，\n\t\t\t// 这个分支主要对应3.2.b之后发送了两个新分片。\n\t\t\t// 虽然发送了新分片，没有发重传，但是这时候收到的ack并没有更新una\n\t\t\t// 说明这个rtt中，之前una的包仍旧没有达到，因此这里认为他是真的超时\n\t\t\t// 关闭frto。对应3.3.a\n\t\t\tif (flag & FLAG_DATA_SACKED || is_dupack)\n\t\t\t\ttp->frto = 0; /* Step 3.a. loss was real */\n\t\t} else if (flag & FLAG_SND_UNA_ADVANCED && !recovered) {\n\t\t\t// 这里进入的条件为\n\t\t\t// 1. snd_nxt == high_seq，还没发送过新分片\n\t\t\t// 2. una更新过，且没有完全恢复\n\t\t\t// 执行3.2.b，发送新分片。\n\t\t\t// 对应论文图中收到了一个更新过snd_una的ack。\n\t\t\ttp->high_seq = tp->snd_nxt;\n\t\t\t/* Step 2.b. Try send new data (but deferred until cwnd\n\t\t\t * is updated in tcp_ack()). Otherwise fall back to\n\t\t\t * the conventional recovery.\n\t\t\t */\n\t\t\t// 3.2.b中判断当前是否可以发送新分片。\n\t\t\tif (tcp_send_head(sk) &&\n\t\t\t    after(tcp_wnd_end(tp), tp->snd_nxt)) {\n\t\t\t\t*rexmit = REXMIT_NEW;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttp->frto = 0;\n\t\t}\n\t}\n\n\t// 已经完全恢复，则撤销对应的恢复操作，并进入TCP_CA_OPEN状态。后续将进入恢复状态。\n\t// 这里主要处理了其他几个不在FRTO可处理的场景，如3.2.a和3.3.a\n\t// 唯一进入这里但frto还可能生效的场景为:\n\t// 发送新分片后，但是收到了一个不是新的sack，且不是一个dup sack。\n\t// 在这种情况下的处理应该和上一个旧的sack相同。\n\t// 个人理解应该是3.3中被忽略的case。\n\tif (recovered) {\n\t\t/* F-RTO RFC5682 sec 3.1 step 2.a and 1st part of step 3.a */\n\t\ttcp_try_undo_recovery(sk);\n\t\treturn;\n\t}\n\tif (tcp_is_reno(tp)) {\n\t\t/* A Reno DUPACK means new data in F-RTO step 2.b above are\n\t\t * delivered. Lower inflight to clock out (re)tranmissions.\n\t\t */\n\t\tif (after(tp->snd_nxt, tp->high_seq) && is_dupack)\n\t\t\ttcp_add_reno_sack(sk);\n\t\telse if (flag & FLAG_SND_UNA_ADVANCED)\n\t\t\ttcp_reset_reno_sack(tp);\n\t}\n\t*rexmit = REXMIT_LOST;\n}\n```\n\n# 3. 简单流程图\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/tcp_frto.png)\n\n# 3.1 常规frto流程\n- 1) RTO超时，发送新分片\n- 2) 收到一个ack，进入tcp\\_process\\_loss处理，此时frto开启，如果延迟的ack更新了una，则直接恢复loss状态。如果刚好等于重传包，这时候先发送新分片。\n- 3) 又一个新的ack到来，这时候由于没有重传包，延迟的ack会更新una，直接撤销丢包处理，离开LOSS状态。\n\n# 3.2 frto恢复失败流程\n- 1) RTO超时，发送新分片\n- 2) 收到一个ack，进入tcp\\_process\\_loss处理，此时frto开启，如上发送新分片。\n- 3) 又一个新的ack到来，这时候由于丢包，不更新对应的una，因此关闭frto，进入重传流程。\n\n","source":"_posts/TCP的FRTO分析.md","raw":"---\ntitle: TCP的FRTO分析\ndate: 2017-04-11 19:04:12\ntags: [TCP, linux, 拥塞控制]\n---\n\n# TCP的FRTO理解\n\n本文主要描述内核4.9.4中的TCP丢包处理与frto相关的操作，主要覆盖使用sack的场景。\n\n# 0. 参考文档\n[1] [RFC-5682](https://tools.ietf.org/html/rfc5682#section-3.1)\n[2] [linuxtcp.ps](https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz)\n[3] [frto.pdf](http://www.sarolahti.fi/pasi/papers/frto-ccr.pdf)\n\n# 1. FRTO要解决的问题\nFRTO主要是用来处理在DSACK生效时，突发的延迟触发RTO超时后，不必要的延迟和重传报文的ack造成了DSACK而产生非必要的快速重传[1]。\n传统的基于DSACK的RTO超时会有如下问题:\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/conventional.png)\n\n- 1) 在16.5s和17s中间最后一个ack到来之前一直处于慢启动阶段，指数发送数据，\n- 2) 18s虚假RTO触发，其实只是延迟，但是这时候RTO工作，重传丢失的报文。\n- 3) 19s的时候延迟包的ack到达，注意到此时ack的数据序列号是大于重传报文的序列号。\n- 4) 延迟的ack使发送端继续重传之后延迟的ack之后的数据(这部分数据之前已经发送过))(19s到19.5s之间的重传)。\n- 5) 在19.8s，之前发送的最大序列号报文被确认，接着由于4中的重传报文陆续到达，接收端发送了一系列以最大序列号报文为ack的Duplicate SACK。\n- 6) 发送端收到这些重复的DSACK后，触发了快速重传，降低了传输性能。\n\n使用FRTO后的效果:\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/frto.png)\n\n- 1) 同上\n- 2) 同上\n- 3) 同上\n- 4) 由于延迟包的ack更新了snd_una，因此这里不重传其余数据，而是发送两个新的分片。\n- 5) 延迟包的ack陆续到达，此时由于未重传的包收到了对应的ack，因此可以判断当前是一个虚假的RTO，继续发送新的数据。\n\n# 1. FRTO rfc解释\n这里主要针对sack的场景，即rfc-5682的section 3。\n\n```\n   1) When the retransmission timer expires, retransmit the first\n      unacknowledged segment and set SpuriousRecovery to FALSE.\n      Following the recommendation in the SACK specification [MMFR96],\n      reset the SACK scoreboard.  If \"RecoveryPoint\" is larger than or\n      equal to SND.UNA, do not enter step 2 of this algorithm.  Instead,\n      set variable \"RecoveryPoint\" to indicate the highest sequence\n      number transmitted so far and continue with slow-start\n      retransmissions following the conventional RTO recovery algorithm.\n\n   2) Wait until the acknowledgment of the data retransmitted due to the\n      timeout arrives at the sender.  If duplicate ACKs arrive before\n      the cumulative acknowledgment for retransmitted data, adjust the\n      scoreboard according to the incoming SACK information.  Stay in\n      step 2 and wait for the next new acknowledgment.  If the\n      retransmission timeout expires again, go to step 1 of the\n      algorithm.  When a new acknowledgment arrives, set variable\n      \"RecoveryPoint\" to indicate the highest sequence number\n      transmitted so far.\n\n      a) If the Cumulative Acknowledgment field covers \"RecoveryPoint\"\n         but not more than \"RecoveryPoint\", revert to the conventional\n         RTO recovery and set the congestion window to no more than 2 *\n         MSS, like a regular TCP would do.  Do not enter step 3 of this\n         algorithm.\n\n      b) Else, if the Cumulative Acknowledgment field does not cover\n         \"RecoveryPoint\" but is larger than SND.UNA, transmit up to two\n         new (previously unsent) segments and proceed to step 3.  If the\n         TCP sender is not able to transmit any previously unsent data\n         -- either due to receiver window limitation or because it does\n         not have any new data to send -- the recommended action is to\n         refrain from entering step 3 of this algorithm.  Rather,\n         continue with slow-start retransmissions following the\n         conventional RTO recovery algorithm.\n\n         It is also possible to apply some of the alternatives for\n         handling window-limited cases discussed in Appendix A.\n\n   3) The next acknowledgment arrives at the sender.  Either a duplicate\n      ACK or a new cumulative ACK (advancing the window) applies in this\n      step.  Other types of ACKs are ignored without any action.\n\n      a) If the Cumulative Acknowledgment field or the SACK information\n         covers more than \"RecoveryPoint\", set the congestion window to\n         no more than 3 * MSS and proceed with the conventional RTO\n         recovery, retransmitting unacknowledged segments.  Take this\n         branch also when the acknowledgment is a duplicate ACK and it\n         does not acknowledge any new, previously unacknowledged data\n         below \"RecoveryPoint\" in the SACK information.  Leave\n         SpuriousRecovery set to FALSE.\n\n      b) If the Cumulative Acknowledgment field or a SACK information in\n         the ACK does not cover more than \"RecoveryPoint\" AND it\n         acknowledges data that was not acknowledged earlier (either\n         with cumulative acknowledgment or using SACK information),\n         declare the timeout spurious and set SpuriousRecovery to\n         SPUR_TO.  The retransmission timeout can be declared spurious,\n         because the segment acknowledged with this ACK was transmitted\n         before the timeout.\n```\n\n注1: RecoveryPoint为tcp中的high_seq，后称恢复点。\n注2: snd_nxt为下一个将要发送的包的包号。\n- 3.1:  当重传定时器超时了，首先重传第一个未确认的分片，同时设置SpuriousRecovery为false，并重置sack的计分板。\n如果恢复点大于等于下一个要发的包(好像基本不可能，最多等于)，则将恢复点设置为当前发送的最大包。进入常规恢复。否则进入step 2。\n- 3.2: 等待重传数据的ack到来。如果重复的ack比新的ack更早到达，则更新相应的sack计分板，同时留在第二步，等待新的ack到来。如果重传定时器再次超时，回到第一步。当新的ack到来后，更新恢复点。\n\t- a) 如果到来的ack中包括了恢复点，但不超过恢复点，撤销至普通恢复，同时拥塞窗口设置不大于2倍MSS。不进入第三步。\n\t- b) 如果到来的ack中不包含恢复点，但是收到的包超过未确认包，发送两个新的分片，并进入步骤3。如果当前发送端无法发送新报文(接收窗口限制或者没有新的应用层数据)，这里建议不要进入步骤3，而是使用恢复步骤。\n-3.3: 下一个ack到来，除了新的ack或者是重复ack，其他ack在这个步骤中都被忽略。\n\t- a) 如果新的ack包含了恢复点，则设置拥塞窗口不超过3倍MSS大小并执行恢复操作，重传未确认分片。这个分支也处理重复ack但是没有确认任何新块的场景。\n\t- b) 如果新的ack或者sack信息中没有包含恢复点，且确认的数据是之前没有确认的，则认为这个超时是一个奇怪的超时，并设置SpuriousRecovery为SPUR_TO。这个重传被标记为奇怪的，因为这个分片在超时前被确认了。\n\n其实论文中的图比rfc这段(恢复点的几个判断理解费力。。)更好理解，也更契合代码，为了识别出虚假的RTO：\n- 超时后先只重发丢失的一个包(3.1)。\n- 判断重传后的第一个新的ack是否更新了snd\\_una，如果更新了snd\\_una，就发送新的数据，在判断虚假RTO之前不重传数据(3.2.b)\n- 如果没重传就已经收到数据，尝试撤销本次RTO，如果撤销成功，这就是一个虚假RTO，进入恢复流程(3.3.b)。如果还是重复ack，则认为这是一个丢包事件(3.3.a)。\n\n# 2. 4.9.4中的代码\n这里主要分析tcp\\_process\\_loss函数。\n\n```cpp\n/* Process an ACK in CA_Loss state. Move to CA_Open if lost data are\n * recovered or spurious. Otherwise retransmits more on partial ACKs.\n */\n// 这个函数中如果可以恢复，则会直接进入CA_OPEN。\n// 不进入CA_OPEN则会直接返回tcp_ack中进行重传(或者是发送新分片)。\nstatic void tcp_process_loss(struct sock *sk, int flag, bool is_dupack,\n\t\t\t     int *rexmit)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t// 完全恢复\n\tbool recovered = !before(tp->snd_una, tp->high_seq);\n\n\t// 最大的未确认包已经发生改变，可能是之前丢包已经恢复，尝试撤销丢包状态。\n\t// 当frto关闭时，这是唯二可以退出LOSS状态的条件。\n\tif ((flag & FLAG_SND_UNA_ADVANCED) &&\n\t    tcp_try_undo_loss(sk, false))\n\t\treturn;\n\n\t// frto在enter_loss时候置位，根据超时时的设置决定是否可能是一个虚假的RTO。\n\tif (tp->frto) { /* F-RTO RFC5682 sec 3.1 (sack enhanced version). */\n\t\t/* Step 3.b. A timeout is spurious if not all data are\n\t\t * lost, i.e., never-retransmitted data are (s)acked.\n\t\t */\n\t\t// #define FLAG_ORIG_SACK_ACKED\t0x200 /* Never retransmitted data are (s)acked\t*/\n\t\t// 包没有丢，因为还没重传就收到了ACK，只是延迟了，这是虚假RTO，撤销丢包状态。\n\t\t// 注: 这里的frto_undo传参为true，必定恢复。\n\t\t// 对应RTO论文图中的延迟包的acks。\n\t\tif ((flag & FLAG_ORIG_SACK_ACKED) &&\n\t\t    tcp_try_undo_loss(sk, true))\n\t\t\treturn;\n\n\t\tif (after(tp->snd_nxt, tp->high_seq)) {\n\t\t\t// 如果是刚进入LOSS状态，会先尝试重传，这时候snd_nxt总是等于high_seq的，\n\t\t\t// 这个分支主要对应3.2.b之后发送了两个新分片。\n\t\t\t// 虽然发送了新分片，没有发重传，但是这时候收到的ack并没有更新una\n\t\t\t// 说明这个rtt中，之前una的包仍旧没有达到，因此这里认为他是真的超时\n\t\t\t// 关闭frto。对应3.3.a\n\t\t\tif (flag & FLAG_DATA_SACKED || is_dupack)\n\t\t\t\ttp->frto = 0; /* Step 3.a. loss was real */\n\t\t} else if (flag & FLAG_SND_UNA_ADVANCED && !recovered) {\n\t\t\t// 这里进入的条件为\n\t\t\t// 1. snd_nxt == high_seq，还没发送过新分片\n\t\t\t// 2. una更新过，且没有完全恢复\n\t\t\t// 执行3.2.b，发送新分片。\n\t\t\t// 对应论文图中收到了一个更新过snd_una的ack。\n\t\t\ttp->high_seq = tp->snd_nxt;\n\t\t\t/* Step 2.b. Try send new data (but deferred until cwnd\n\t\t\t * is updated in tcp_ack()). Otherwise fall back to\n\t\t\t * the conventional recovery.\n\t\t\t */\n\t\t\t// 3.2.b中判断当前是否可以发送新分片。\n\t\t\tif (tcp_send_head(sk) &&\n\t\t\t    after(tcp_wnd_end(tp), tp->snd_nxt)) {\n\t\t\t\t*rexmit = REXMIT_NEW;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttp->frto = 0;\n\t\t}\n\t}\n\n\t// 已经完全恢复，则撤销对应的恢复操作，并进入TCP_CA_OPEN状态。后续将进入恢复状态。\n\t// 这里主要处理了其他几个不在FRTO可处理的场景，如3.2.a和3.3.a\n\t// 唯一进入这里但frto还可能生效的场景为:\n\t// 发送新分片后，但是收到了一个不是新的sack，且不是一个dup sack。\n\t// 在这种情况下的处理应该和上一个旧的sack相同。\n\t// 个人理解应该是3.3中被忽略的case。\n\tif (recovered) {\n\t\t/* F-RTO RFC5682 sec 3.1 step 2.a and 1st part of step 3.a */\n\t\ttcp_try_undo_recovery(sk);\n\t\treturn;\n\t}\n\tif (tcp_is_reno(tp)) {\n\t\t/* A Reno DUPACK means new data in F-RTO step 2.b above are\n\t\t * delivered. Lower inflight to clock out (re)tranmissions.\n\t\t */\n\t\tif (after(tp->snd_nxt, tp->high_seq) && is_dupack)\n\t\t\ttcp_add_reno_sack(sk);\n\t\telse if (flag & FLAG_SND_UNA_ADVANCED)\n\t\t\ttcp_reset_reno_sack(tp);\n\t}\n\t*rexmit = REXMIT_LOST;\n}\n```\n\n# 3. 简单流程图\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/tcp_frto.png)\n\n# 3.1 常规frto流程\n- 1) RTO超时，发送新分片\n- 2) 收到一个ack，进入tcp\\_process\\_loss处理，此时frto开启，如果延迟的ack更新了una，则直接恢复loss状态。如果刚好等于重传包，这时候先发送新分片。\n- 3) 又一个新的ack到来，这时候由于没有重传包，延迟的ack会更新una，直接撤销丢包处理，离开LOSS状态。\n\n# 3.2 frto恢复失败流程\n- 1) RTO超时，发送新分片\n- 2) 收到一个ack，进入tcp\\_process\\_loss处理，此时frto开启，如上发送新分片。\n- 3) 又一个新的ack到来，这时候由于丢包，不更新对应的una，因此关闭frto，进入重传流程。\n\n","slug":"TCP的FRTO分析","published":1,"updated":"2017-05-11T02:28:31.000Z","_id":"cj2gzs4jq0005r8c39mlsqsyu","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"TCP的FRTO理解\"><a href=\"#TCP的FRTO理解\" class=\"headerlink\" title=\"TCP的FRTO理解\"></a>TCP的FRTO理解</h1><p>本文主要描述内核4.9.4中的TCP丢包处理与frto相关的操作，主要覆盖使用sack的场景。</p>\n<h1 id=\"0-参考文档\"><a href=\"#0-参考文档\" class=\"headerlink\" title=\"0. 参考文档\"></a>0. 参考文档</h1><p>[1] <a href=\"https://tools.ietf.org/html/rfc5682#section-3.1\" target=\"_blank\" rel=\"external\">RFC-5682</a><br>[2] <a href=\"https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz\" target=\"_blank\" rel=\"external\">linuxtcp.ps</a><br>[3] <a href=\"http://www.sarolahti.fi/pasi/papers/frto-ccr.pdf\" target=\"_blank\" rel=\"external\">frto.pdf</a></p>\n<h1 id=\"1-FRTO要解决的问题\"><a href=\"#1-FRTO要解决的问题\" class=\"headerlink\" title=\"1. FRTO要解决的问题\"></a>1. FRTO要解决的问题</h1><p>FRTO主要是用来处理在DSACK生效时，突发的延迟触发RTO超时后，不必要的延迟和重传报文的ack造成了DSACK而产生非必要的快速重传[1]。<br>传统的基于DSACK的RTO超时会有如下问题:</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/conventional.png\" alt=\"\"></p>\n<ul>\n<li>1) 在16.5s和17s中间最后一个ack到来之前一直处于慢启动阶段，指数发送数据，</li>\n<li>2) 18s虚假RTO触发，其实只是延迟，但是这时候RTO工作，重传丢失的报文。</li>\n<li>3) 19s的时候延迟包的ack到达，注意到此时ack的数据序列号是大于重传报文的序列号。</li>\n<li>4) 延迟的ack使发送端继续重传之后延迟的ack之后的数据(这部分数据之前已经发送过))(19s到19.5s之间的重传)。</li>\n<li>5) 在19.8s，之前发送的最大序列号报文被确认，接着由于4中的重传报文陆续到达，接收端发送了一系列以最大序列号报文为ack的Duplicate SACK。</li>\n<li>6) 发送端收到这些重复的DSACK后，触发了快速重传，降低了传输性能。</li>\n</ul>\n<p>使用FRTO后的效果:</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/frto.png\" alt=\"\"></p>\n<ul>\n<li>1) 同上</li>\n<li>2) 同上</li>\n<li>3) 同上</li>\n<li>4) 由于延迟包的ack更新了snd_una，因此这里不重传其余数据，而是发送两个新的分片。</li>\n<li>5) 延迟包的ack陆续到达，此时由于未重传的包收到了对应的ack，因此可以判断当前是一个虚假的RTO，继续发送新的数据。</li>\n</ul>\n<h1 id=\"1-FRTO-rfc解释\"><a href=\"#1-FRTO-rfc解释\" class=\"headerlink\" title=\"1. FRTO rfc解释\"></a>1. FRTO rfc解释</h1><p>这里主要针对sack的场景，即rfc-5682的section 3。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\">1) When the retransmission timer expires, retransmit the first</div><div class=\"line\">   unacknowledged segment and set SpuriousRecovery to FALSE.</div><div class=\"line\">   Following the recommendation in the SACK specification [MMFR96],</div><div class=\"line\">   reset the SACK scoreboard.  If &quot;RecoveryPoint&quot; is larger than or</div><div class=\"line\">   equal to SND.UNA, do not enter step 2 of this algorithm.  Instead,</div><div class=\"line\">   set variable &quot;RecoveryPoint&quot; to indicate the highest sequence</div><div class=\"line\">   number transmitted so far and continue with slow-start</div><div class=\"line\">   retransmissions following the conventional RTO recovery algorithm.</div><div class=\"line\"></div><div class=\"line\">2) Wait until the acknowledgment of the data retransmitted due to the</div><div class=\"line\">   timeout arrives at the sender.  If duplicate ACKs arrive before</div><div class=\"line\">   the cumulative acknowledgment for retransmitted data, adjust the</div><div class=\"line\">   scoreboard according to the incoming SACK information.  Stay in</div><div class=\"line\">   step 2 and wait for the next new acknowledgment.  If the</div><div class=\"line\">   retransmission timeout expires again, go to step 1 of the</div><div class=\"line\">   algorithm.  When a new acknowledgment arrives, set variable</div><div class=\"line\">   &quot;RecoveryPoint&quot; to indicate the highest sequence number</div><div class=\"line\">   transmitted so far.</div><div class=\"line\"></div><div class=\"line\">   a) If the Cumulative Acknowledgment field covers &quot;RecoveryPoint&quot;</div><div class=\"line\">      but not more than &quot;RecoveryPoint&quot;, revert to the conventional</div><div class=\"line\">      RTO recovery and set the congestion window to no more than 2 *</div><div class=\"line\">      MSS, like a regular TCP would do.  Do not enter step 3 of this</div><div class=\"line\">      algorithm.</div><div class=\"line\"></div><div class=\"line\">   b) Else, if the Cumulative Acknowledgment field does not cover</div><div class=\"line\">      &quot;RecoveryPoint&quot; but is larger than SND.UNA, transmit up to two</div><div class=\"line\">      new (previously unsent) segments and proceed to step 3.  If the</div><div class=\"line\">      TCP sender is not able to transmit any previously unsent data</div><div class=\"line\">      -- either due to receiver window limitation or because it does</div><div class=\"line\">      not have any new data to send -- the recommended action is to</div><div class=\"line\">      refrain from entering step 3 of this algorithm.  Rather,</div><div class=\"line\">      continue with slow-start retransmissions following the</div><div class=\"line\">      conventional RTO recovery algorithm.</div><div class=\"line\"></div><div class=\"line\">      It is also possible to apply some of the alternatives for</div><div class=\"line\">      handling window-limited cases discussed in Appendix A.</div><div class=\"line\"></div><div class=\"line\">3) The next acknowledgment arrives at the sender.  Either a duplicate</div><div class=\"line\">   ACK or a new cumulative ACK (advancing the window) applies in this</div><div class=\"line\">   step.  Other types of ACKs are ignored without any action.</div><div class=\"line\"></div><div class=\"line\">   a) If the Cumulative Acknowledgment field or the SACK information</div><div class=\"line\">      covers more than &quot;RecoveryPoint&quot;, set the congestion window to</div><div class=\"line\">      no more than 3 * MSS and proceed with the conventional RTO</div><div class=\"line\">      recovery, retransmitting unacknowledged segments.  Take this</div><div class=\"line\">      branch also when the acknowledgment is a duplicate ACK and it</div><div class=\"line\">      does not acknowledge any new, previously unacknowledged data</div><div class=\"line\">      below &quot;RecoveryPoint&quot; in the SACK information.  Leave</div><div class=\"line\">      SpuriousRecovery set to FALSE.</div><div class=\"line\"></div><div class=\"line\">   b) If the Cumulative Acknowledgment field or a SACK information in</div><div class=\"line\">      the ACK does not cover more than &quot;RecoveryPoint&quot; AND it</div><div class=\"line\">      acknowledges data that was not acknowledged earlier (either</div><div class=\"line\">      with cumulative acknowledgment or using SACK information),</div><div class=\"line\">      declare the timeout spurious and set SpuriousRecovery to</div><div class=\"line\">      SPUR_TO.  The retransmission timeout can be declared spurious,</div><div class=\"line\">      because the segment acknowledged with this ACK was transmitted</div><div class=\"line\">      before the timeout.</div></pre></td></tr></table></figure>\n<p>注1: RecoveryPoint为tcp中的high_seq，后称恢复点。<br>注2: snd_nxt为下一个将要发送的包的包号。</p>\n<ul>\n<li>3.1:  当重传定时器超时了，首先重传第一个未确认的分片，同时设置SpuriousRecovery为false，并重置sack的计分板。<br>如果恢复点大于等于下一个要发的包(好像基本不可能，最多等于)，则将恢复点设置为当前发送的最大包。进入常规恢复。否则进入step 2。</li>\n<li>3.2: 等待重传数据的ack到来。如果重复的ack比新的ack更早到达，则更新相应的sack计分板，同时留在第二步，等待新的ack到来。如果重传定时器再次超时，回到第一步。当新的ack到来后，更新恢复点。<ul>\n<li>a) 如果到来的ack中包括了恢复点，但不超过恢复点，撤销至普通恢复，同时拥塞窗口设置不大于2倍MSS。不进入第三步。</li>\n<li>b) 如果到来的ack中不包含恢复点，但是收到的包超过未确认包，发送两个新的分片，并进入步骤3。如果当前发送端无法发送新报文(接收窗口限制或者没有新的应用层数据)，这里建议不要进入步骤3，而是使用恢复步骤。<br>-3.3: 下一个ack到来，除了新的ack或者是重复ack，其他ack在这个步骤中都被忽略。</li>\n<li>a) 如果新的ack包含了恢复点，则设置拥塞窗口不超过3倍MSS大小并执行恢复操作，重传未确认分片。这个分支也处理重复ack但是没有确认任何新块的场景。</li>\n<li>b) 如果新的ack或者sack信息中没有包含恢复点，且确认的数据是之前没有确认的，则认为这个超时是一个奇怪的超时，并设置SpuriousRecovery为SPUR_TO。这个重传被标记为奇怪的，因为这个分片在超时前被确认了。</li>\n</ul>\n</li>\n</ul>\n<p>其实论文中的图比rfc这段(恢复点的几个判断理解费力。。)更好理解，也更契合代码，为了识别出虚假的RTO：</p>\n<ul>\n<li>超时后先只重发丢失的一个包(3.1)。</li>\n<li>判断重传后的第一个新的ack是否更新了snd_una，如果更新了snd_una，就发送新的数据，在判断虚假RTO之前不重传数据(3.2.b)</li>\n<li>如果没重传就已经收到数据，尝试撤销本次RTO，如果撤销成功，这就是一个虚假RTO，进入恢复流程(3.3.b)。如果还是重复ack，则认为这是一个丢包事件(3.3.a)。</li>\n</ul>\n<h1 id=\"2-4-9-4中的代码\"><a href=\"#2-4-9-4中的代码\" class=\"headerlink\" title=\"2. 4.9.4中的代码\"></a>2. 4.9.4中的代码</h1><p>这里主要分析tcp_process_loss函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Process an ACK in CA_Loss state. Move to CA_Open if lost data are</span></div><div class=\"line\"> * recovered or spurious. Otherwise retransmits more on partial ACKs.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"comment\">// 这个函数中如果可以恢复，则会直接进入CA_OPEN。</span></div><div class=\"line\"><span class=\"comment\">// 不进入CA_OPEN则会直接返回tcp_ack中进行重传(或者是发送新分片)。</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tcp_process_loss</span><span class=\"params\">(<span class=\"keyword\">struct</span> sock *sk, <span class=\"keyword\">int</span> flag, <span class=\"keyword\">bool</span> is_dupack,</span></span></div><div class=\"line\">\t\t\t     <span class=\"keyword\">int</span> *rexmit)</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">struct</span> tcp_sock *tp = tcp_sk(sk);</div><div class=\"line\">\t<span class=\"comment\">// 完全恢复</span></div><div class=\"line\">\t<span class=\"keyword\">bool</span> recovered = !before(tp-&gt;snd_una, tp-&gt;high_seq);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 最大的未确认包已经发生改变，可能是之前丢包已经恢复，尝试撤销丢包状态。</span></div><div class=\"line\">\t<span class=\"comment\">// 当frto关闭时，这是唯二可以退出LOSS状态的条件。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> ((flag &amp; FLAG_SND_UNA_ADVANCED) &amp;&amp;</div><div class=\"line\">\t    tcp_try_undo_loss(sk, <span class=\"literal\">false</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// frto在enter_loss时候置位，根据超时时的设置决定是否可能是一个虚假的RTO。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (tp-&gt;frto) &#123; <span class=\"comment\">/* F-RTO RFC5682 sec 3.1 (sack enhanced version). */</span></div><div class=\"line\">\t\t<span class=\"comment\">/* Step 3.b. A timeout is spurious if not all data are</span></div><div class=\"line\">\t\t * lost, i.e., never-retransmitted data are (s)acked.</div><div class=\"line\">\t\t */</div><div class=\"line\">\t\t<span class=\"comment\">// #define FLAG_ORIG_SACK_ACKED\t0x200 /* Never retransmitted data are (s)acked\t*/</span></div><div class=\"line\">\t\t<span class=\"comment\">// 包没有丢，因为还没重传就收到了ACK，只是延迟了，这是虚假RTO，撤销丢包状态。</span></div><div class=\"line\">\t\t<span class=\"comment\">// 注: 这里的frto_undo传参为true，必定恢复。</span></div><div class=\"line\">\t\t<span class=\"comment\">// 对应RTO论文图中的延迟包的acks。</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ((flag &amp; FLAG_ORIG_SACK_ACKED) &amp;&amp;</div><div class=\"line\">\t\t    tcp_try_undo_loss(sk, <span class=\"literal\">true</span>))</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (after(tp-&gt;snd_nxt, tp-&gt;high_seq)) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 如果是刚进入LOSS状态，会先尝试重传，这时候snd_nxt总是等于high_seq的，</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 这个分支主要对应3.2.b之后发送了两个新分片。</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 虽然发送了新分片，没有发重传，但是这时候收到的ack并没有更新una</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 说明这个rtt中，之前una的包仍旧没有达到，因此这里认为他是真的超时</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 关闭frto。对应3.3.a</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (flag &amp; FLAG_DATA_SACKED || is_dupack)</div><div class=\"line\">\t\t\t\ttp-&gt;frto = <span class=\"number\">0</span>; <span class=\"comment\">/* Step 3.a. loss was real */</span></div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flag &amp; FLAG_SND_UNA_ADVANCED &amp;&amp; !recovered) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 这里进入的条件为</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 1. snd_nxt == high_seq，还没发送过新分片</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 2. una更新过，且没有完全恢复</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 执行3.2.b，发送新分片。</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 对应论文图中收到了一个更新过snd_una的ack。</span></div><div class=\"line\">\t\t\ttp-&gt;high_seq = tp-&gt;snd_nxt;</div><div class=\"line\">\t\t\t<span class=\"comment\">/* Step 2.b. Try send new data (but deferred until cwnd</span></div><div class=\"line\">\t\t\t * is updated in tcp_ack()). Otherwise fall back to</div><div class=\"line\">\t\t\t * the conventional recovery.</div><div class=\"line\">\t\t\t */</div><div class=\"line\">\t\t\t<span class=\"comment\">// 3.2.b中判断当前是否可以发送新分片。</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tcp_send_head(sk) &amp;&amp;</div><div class=\"line\">\t\t\t    after(tcp_wnd_end(tp), tp-&gt;snd_nxt)) &#123;</div><div class=\"line\">\t\t\t\t*rexmit = REXMIT_NEW;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\ttp-&gt;frto = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 已经完全恢复，则撤销对应的恢复操作，并进入TCP_CA_OPEN状态。后续将进入恢复状态。</span></div><div class=\"line\">\t<span class=\"comment\">// 这里主要处理了其他几个不在FRTO可处理的场景，如3.2.a和3.3.a</span></div><div class=\"line\">\t<span class=\"comment\">// 唯一进入这里但frto还可能生效的场景为:</span></div><div class=\"line\">\t<span class=\"comment\">// 发送新分片后，但是收到了一个不是新的sack，且不是一个dup sack。</span></div><div class=\"line\">\t<span class=\"comment\">// 在这种情况下的处理应该和上一个旧的sack相同。</span></div><div class=\"line\">\t<span class=\"comment\">// 个人理解应该是3.3中被忽略的case。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (recovered) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">/* F-RTO RFC5682 sec 3.1 step 2.a and 1st part of step 3.a */</span></div><div class=\"line\">\t\ttcp_try_undo_recovery(sk);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (tcp_is_reno(tp)) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">/* A Reno DUPACK means new data in F-RTO step 2.b above are</span></div><div class=\"line\">\t\t * delivered. Lower inflight to clock out (re)tranmissions.</div><div class=\"line\">\t\t */</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (after(tp-&gt;snd_nxt, tp-&gt;high_seq) &amp;&amp; is_dupack)</div><div class=\"line\">\t\t\ttcp_add_reno_sack(sk);</div><div class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flag &amp; FLAG_SND_UNA_ADVANCED)</div><div class=\"line\">\t\t\ttcp_reset_reno_sack(tp);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t*rexmit = REXMIT_LOST;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-简单流程图\"><a href=\"#3-简单流程图\" class=\"headerlink\" title=\"3. 简单流程图\"></a>3. 简单流程图</h1><p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/tcp_frto.png\" alt=\"\"></p>\n<h1 id=\"3-1-常规frto流程\"><a href=\"#3-1-常规frto流程\" class=\"headerlink\" title=\"3.1 常规frto流程\"></a>3.1 常规frto流程</h1><ul>\n<li>1) RTO超时，发送新分片</li>\n<li>2) 收到一个ack，进入tcp_process_loss处理，此时frto开启，如果延迟的ack更新了una，则直接恢复loss状态。如果刚好等于重传包，这时候先发送新分片。</li>\n<li>3) 又一个新的ack到来，这时候由于没有重传包，延迟的ack会更新una，直接撤销丢包处理，离开LOSS状态。</li>\n</ul>\n<h1 id=\"3-2-frto恢复失败流程\"><a href=\"#3-2-frto恢复失败流程\" class=\"headerlink\" title=\"3.2 frto恢复失败流程\"></a>3.2 frto恢复失败流程</h1><ul>\n<li>1) RTO超时，发送新分片</li>\n<li>2) 收到一个ack，进入tcp_process_loss处理，此时frto开启，如上发送新分片。</li>\n<li>3) 又一个新的ack到来，这时候由于丢包，不更新对应的una，因此关闭frto，进入重传流程。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"TCP的FRTO理解\"><a href=\"#TCP的FRTO理解\" class=\"headerlink\" title=\"TCP的FRTO理解\"></a>TCP的FRTO理解</h1><p>本文主要描述内核4.9.4中的TCP丢包处理与frto相关的操作，主要覆盖使用sack的场景。</p>\n<h1 id=\"0-参考文档\"><a href=\"#0-参考文档\" class=\"headerlink\" title=\"0. 参考文档\"></a>0. 参考文档</h1><p>[1] <a href=\"https://tools.ietf.org/html/rfc5682#section-3.1\">RFC-5682</a><br>[2] <a href=\"https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz\">linuxtcp.ps</a><br>[3] <a href=\"http://www.sarolahti.fi/pasi/papers/frto-ccr.pdf\">frto.pdf</a></p>\n<h1 id=\"1-FRTO要解决的问题\"><a href=\"#1-FRTO要解决的问题\" class=\"headerlink\" title=\"1. FRTO要解决的问题\"></a>1. FRTO要解决的问题</h1><p>FRTO主要是用来处理在DSACK生效时，突发的延迟触发RTO超时后，不必要的延迟和重传报文的ack造成了DSACK而产生非必要的快速重传[1]。<br>传统的基于DSACK的RTO超时会有如下问题:</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/conventional.png\" alt=\"\"></p>\n<ul>\n<li>1) 在16.5s和17s中间最后一个ack到来之前一直处于慢启动阶段，指数发送数据，</li>\n<li>2) 18s虚假RTO触发，其实只是延迟，但是这时候RTO工作，重传丢失的报文。</li>\n<li>3) 19s的时候延迟包的ack到达，注意到此时ack的数据序列号是大于重传报文的序列号。</li>\n<li>4) 延迟的ack使发送端继续重传之后延迟的ack之后的数据(这部分数据之前已经发送过))(19s到19.5s之间的重传)。</li>\n<li>5) 在19.8s，之前发送的最大序列号报文被确认，接着由于4中的重传报文陆续到达，接收端发送了一系列以最大序列号报文为ack的Duplicate SACK。</li>\n<li>6) 发送端收到这些重复的DSACK后，触发了快速重传，降低了传输性能。</li>\n</ul>\n<p>使用FRTO后的效果:</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/frto.png\" alt=\"\"></p>\n<ul>\n<li>1) 同上</li>\n<li>2) 同上</li>\n<li>3) 同上</li>\n<li>4) 由于延迟包的ack更新了snd_una，因此这里不重传其余数据，而是发送两个新的分片。</li>\n<li>5) 延迟包的ack陆续到达，此时由于未重传的包收到了对应的ack，因此可以判断当前是一个虚假的RTO，继续发送新的数据。</li>\n</ul>\n<h1 id=\"1-FRTO-rfc解释\"><a href=\"#1-FRTO-rfc解释\" class=\"headerlink\" title=\"1. FRTO rfc解释\"></a>1. FRTO rfc解释</h1><p>这里主要针对sack的场景，即rfc-5682的section 3。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\">1) When the retransmission timer expires, retransmit the first</div><div class=\"line\">   unacknowledged segment and set SpuriousRecovery to FALSE.</div><div class=\"line\">   Following the recommendation in the SACK specification [MMFR96],</div><div class=\"line\">   reset the SACK scoreboard.  If &quot;RecoveryPoint&quot; is larger than or</div><div class=\"line\">   equal to SND.UNA, do not enter step 2 of this algorithm.  Instead,</div><div class=\"line\">   set variable &quot;RecoveryPoint&quot; to indicate the highest sequence</div><div class=\"line\">   number transmitted so far and continue with slow-start</div><div class=\"line\">   retransmissions following the conventional RTO recovery algorithm.</div><div class=\"line\"></div><div class=\"line\">2) Wait until the acknowledgment of the data retransmitted due to the</div><div class=\"line\">   timeout arrives at the sender.  If duplicate ACKs arrive before</div><div class=\"line\">   the cumulative acknowledgment for retransmitted data, adjust the</div><div class=\"line\">   scoreboard according to the incoming SACK information.  Stay in</div><div class=\"line\">   step 2 and wait for the next new acknowledgment.  If the</div><div class=\"line\">   retransmission timeout expires again, go to step 1 of the</div><div class=\"line\">   algorithm.  When a new acknowledgment arrives, set variable</div><div class=\"line\">   &quot;RecoveryPoint&quot; to indicate the highest sequence number</div><div class=\"line\">   transmitted so far.</div><div class=\"line\"></div><div class=\"line\">   a) If the Cumulative Acknowledgment field covers &quot;RecoveryPoint&quot;</div><div class=\"line\">      but not more than &quot;RecoveryPoint&quot;, revert to the conventional</div><div class=\"line\">      RTO recovery and set the congestion window to no more than 2 *</div><div class=\"line\">      MSS, like a regular TCP would do.  Do not enter step 3 of this</div><div class=\"line\">      algorithm.</div><div class=\"line\"></div><div class=\"line\">   b) Else, if the Cumulative Acknowledgment field does not cover</div><div class=\"line\">      &quot;RecoveryPoint&quot; but is larger than SND.UNA, transmit up to two</div><div class=\"line\">      new (previously unsent) segments and proceed to step 3.  If the</div><div class=\"line\">      TCP sender is not able to transmit any previously unsent data</div><div class=\"line\">      -- either due to receiver window limitation or because it does</div><div class=\"line\">      not have any new data to send -- the recommended action is to</div><div class=\"line\">      refrain from entering step 3 of this algorithm.  Rather,</div><div class=\"line\">      continue with slow-start retransmissions following the</div><div class=\"line\">      conventional RTO recovery algorithm.</div><div class=\"line\"></div><div class=\"line\">      It is also possible to apply some of the alternatives for</div><div class=\"line\">      handling window-limited cases discussed in Appendix A.</div><div class=\"line\"></div><div class=\"line\">3) The next acknowledgment arrives at the sender.  Either a duplicate</div><div class=\"line\">   ACK or a new cumulative ACK (advancing the window) applies in this</div><div class=\"line\">   step.  Other types of ACKs are ignored without any action.</div><div class=\"line\"></div><div class=\"line\">   a) If the Cumulative Acknowledgment field or the SACK information</div><div class=\"line\">      covers more than &quot;RecoveryPoint&quot;, set the congestion window to</div><div class=\"line\">      no more than 3 * MSS and proceed with the conventional RTO</div><div class=\"line\">      recovery, retransmitting unacknowledged segments.  Take this</div><div class=\"line\">      branch also when the acknowledgment is a duplicate ACK and it</div><div class=\"line\">      does not acknowledge any new, previously unacknowledged data</div><div class=\"line\">      below &quot;RecoveryPoint&quot; in the SACK information.  Leave</div><div class=\"line\">      SpuriousRecovery set to FALSE.</div><div class=\"line\"></div><div class=\"line\">   b) If the Cumulative Acknowledgment field or a SACK information in</div><div class=\"line\">      the ACK does not cover more than &quot;RecoveryPoint&quot; AND it</div><div class=\"line\">      acknowledges data that was not acknowledged earlier (either</div><div class=\"line\">      with cumulative acknowledgment or using SACK information),</div><div class=\"line\">      declare the timeout spurious and set SpuriousRecovery to</div><div class=\"line\">      SPUR_TO.  The retransmission timeout can be declared spurious,</div><div class=\"line\">      because the segment acknowledged with this ACK was transmitted</div><div class=\"line\">      before the timeout.</div></pre></td></tr></table></figure>\n<p>注1: RecoveryPoint为tcp中的high_seq，后称恢复点。<br>注2: snd_nxt为下一个将要发送的包的包号。</p>\n<ul>\n<li>3.1:  当重传定时器超时了，首先重传第一个未确认的分片，同时设置SpuriousRecovery为false，并重置sack的计分板。<br>如果恢复点大于等于下一个要发的包(好像基本不可能，最多等于)，则将恢复点设置为当前发送的最大包。进入常规恢复。否则进入step 2。</li>\n<li>3.2: 等待重传数据的ack到来。如果重复的ack比新的ack更早到达，则更新相应的sack计分板，同时留在第二步，等待新的ack到来。如果重传定时器再次超时，回到第一步。当新的ack到来后，更新恢复点。<ul>\n<li>a) 如果到来的ack中包括了恢复点，但不超过恢复点，撤销至普通恢复，同时拥塞窗口设置不大于2倍MSS。不进入第三步。</li>\n<li>b) 如果到来的ack中不包含恢复点，但是收到的包超过未确认包，发送两个新的分片，并进入步骤3。如果当前发送端无法发送新报文(接收窗口限制或者没有新的应用层数据)，这里建议不要进入步骤3，而是使用恢复步骤。<br>-3.3: 下一个ack到来，除了新的ack或者是重复ack，其他ack在这个步骤中都被忽略。</li>\n<li>a) 如果新的ack包含了恢复点，则设置拥塞窗口不超过3倍MSS大小并执行恢复操作，重传未确认分片。这个分支也处理重复ack但是没有确认任何新块的场景。</li>\n<li>b) 如果新的ack或者sack信息中没有包含恢复点，且确认的数据是之前没有确认的，则认为这个超时是一个奇怪的超时，并设置SpuriousRecovery为SPUR_TO。这个重传被标记为奇怪的，因为这个分片在超时前被确认了。</li>\n</ul>\n</li>\n</ul>\n<p>其实论文中的图比rfc这段(恢复点的几个判断理解费力。。)更好理解，也更契合代码，为了识别出虚假的RTO：</p>\n<ul>\n<li>超时后先只重发丢失的一个包(3.1)。</li>\n<li>判断重传后的第一个新的ack是否更新了snd_una，如果更新了snd_una，就发送新的数据，在判断虚假RTO之前不重传数据(3.2.b)</li>\n<li>如果没重传就已经收到数据，尝试撤销本次RTO，如果撤销成功，这就是一个虚假RTO，进入恢复流程(3.3.b)。如果还是重复ack，则认为这是一个丢包事件(3.3.a)。</li>\n</ul>\n<h1 id=\"2-4-9-4中的代码\"><a href=\"#2-4-9-4中的代码\" class=\"headerlink\" title=\"2. 4.9.4中的代码\"></a>2. 4.9.4中的代码</h1><p>这里主要分析tcp_process_loss函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Process an ACK in CA_Loss state. Move to CA_Open if lost data are</div><div class=\"line\"> * recovered or spurious. Otherwise retransmits more on partial ACKs.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"comment\">// 这个函数中如果可以恢复，则会直接进入CA_OPEN。</span></div><div class=\"line\"><span class=\"comment\">// 不进入CA_OPEN则会直接返回tcp_ack中进行重传(或者是发送新分片)。</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tcp_process_loss</span><span class=\"params\">(<span class=\"keyword\">struct</span> sock *sk, <span class=\"keyword\">int</span> flag, <span class=\"keyword\">bool</span> is_dupack,</div><div class=\"line\">\t\t\t     <span class=\"keyword\">int</span> *rexmit)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">struct</span> tcp_sock *tp = tcp_sk(sk);</div><div class=\"line\">\t<span class=\"comment\">// 完全恢复</span></div><div class=\"line\">\t<span class=\"keyword\">bool</span> recovered = !before(tp-&gt;snd_una, tp-&gt;high_seq);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 最大的未确认包已经发生改变，可能是之前丢包已经恢复，尝试撤销丢包状态。</span></div><div class=\"line\">\t<span class=\"comment\">// 当frto关闭时，这是唯二可以退出LOSS状态的条件。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> ((flag &amp; FLAG_SND_UNA_ADVANCED) &amp;&amp;</div><div class=\"line\">\t    tcp_try_undo_loss(sk, <span class=\"literal\">false</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// frto在enter_loss时候置位，根据超时时的设置决定是否可能是一个虚假的RTO。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (tp-&gt;frto) &#123; <span class=\"comment\">/* F-RTO RFC5682 sec 3.1 (sack enhanced version). */</span></div><div class=\"line\">\t\t<span class=\"comment\">/* Step 3.b. A timeout is spurious if not all data are</div><div class=\"line\">\t\t * lost, i.e., never-retransmitted data are (s)acked.</div><div class=\"line\">\t\t */</span></div><div class=\"line\">\t\t<span class=\"comment\">// #define FLAG_ORIG_SACK_ACKED\t0x200 /* Never retransmitted data are (s)acked\t*/</span></div><div class=\"line\">\t\t<span class=\"comment\">// 包没有丢，因为还没重传就收到了ACK，只是延迟了，这是虚假RTO，撤销丢包状态。</span></div><div class=\"line\">\t\t<span class=\"comment\">// 注: 这里的frto_undo传参为true，必定恢复。</span></div><div class=\"line\">\t\t<span class=\"comment\">// 对应RTO论文图中的延迟包的acks。</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ((flag &amp; FLAG_ORIG_SACK_ACKED) &amp;&amp;</div><div class=\"line\">\t\t    tcp_try_undo_loss(sk, <span class=\"literal\">true</span>))</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (after(tp-&gt;snd_nxt, tp-&gt;high_seq)) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 如果是刚进入LOSS状态，会先尝试重传，这时候snd_nxt总是等于high_seq的，</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 这个分支主要对应3.2.b之后发送了两个新分片。</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 虽然发送了新分片，没有发重传，但是这时候收到的ack并没有更新una</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 说明这个rtt中，之前una的包仍旧没有达到，因此这里认为他是真的超时</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 关闭frto。对应3.3.a</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (flag &amp; FLAG_DATA_SACKED || is_dupack)</div><div class=\"line\">\t\t\t\ttp-&gt;frto = <span class=\"number\">0</span>; <span class=\"comment\">/* Step 3.a. loss was real */</span></div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flag &amp; FLAG_SND_UNA_ADVANCED &amp;&amp; !recovered) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 这里进入的条件为</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 1. snd_nxt == high_seq，还没发送过新分片</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 2. una更新过，且没有完全恢复</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 执行3.2.b，发送新分片。</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 对应论文图中收到了一个更新过snd_una的ack。</span></div><div class=\"line\">\t\t\ttp-&gt;high_seq = tp-&gt;snd_nxt;</div><div class=\"line\">\t\t\t<span class=\"comment\">/* Step 2.b. Try send new data (but deferred until cwnd</div><div class=\"line\">\t\t\t * is updated in tcp_ack()). Otherwise fall back to</div><div class=\"line\">\t\t\t * the conventional recovery.</div><div class=\"line\">\t\t\t */</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 3.2.b中判断当前是否可以发送新分片。</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tcp_send_head(sk) &amp;&amp;</div><div class=\"line\">\t\t\t    after(tcp_wnd_end(tp), tp-&gt;snd_nxt)) &#123;</div><div class=\"line\">\t\t\t\t*rexmit = REXMIT_NEW;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\ttp-&gt;frto = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 已经完全恢复，则撤销对应的恢复操作，并进入TCP_CA_OPEN状态。后续将进入恢复状态。</span></div><div class=\"line\">\t<span class=\"comment\">// 这里主要处理了其他几个不在FRTO可处理的场景，如3.2.a和3.3.a</span></div><div class=\"line\">\t<span class=\"comment\">// 唯一进入这里但frto还可能生效的场景为:</span></div><div class=\"line\">\t<span class=\"comment\">// 发送新分片后，但是收到了一个不是新的sack，且不是一个dup sack。</span></div><div class=\"line\">\t<span class=\"comment\">// 在这种情况下的处理应该和上一个旧的sack相同。</span></div><div class=\"line\">\t<span class=\"comment\">// 个人理解应该是3.3中被忽略的case。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (recovered) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">/* F-RTO RFC5682 sec 3.1 step 2.a and 1st part of step 3.a */</span></div><div class=\"line\">\t\ttcp_try_undo_recovery(sk);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (tcp_is_reno(tp)) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">/* A Reno DUPACK means new data in F-RTO step 2.b above are</div><div class=\"line\">\t\t * delivered. Lower inflight to clock out (re)tranmissions.</div><div class=\"line\">\t\t */</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (after(tp-&gt;snd_nxt, tp-&gt;high_seq) &amp;&amp; is_dupack)</div><div class=\"line\">\t\t\ttcp_add_reno_sack(sk);</div><div class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flag &amp; FLAG_SND_UNA_ADVANCED)</div><div class=\"line\">\t\t\ttcp_reset_reno_sack(tp);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t*rexmit = REXMIT_LOST;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-简单流程图\"><a href=\"#3-简单流程图\" class=\"headerlink\" title=\"3. 简单流程图\"></a>3. 简单流程图</h1><p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP_FRTO/tcp_frto.png\" alt=\"\"></p>\n<h1 id=\"3-1-常规frto流程\"><a href=\"#3-1-常规frto流程\" class=\"headerlink\" title=\"3.1 常规frto流程\"></a>3.1 常规frto流程</h1><ul>\n<li>1) RTO超时，发送新分片</li>\n<li>2) 收到一个ack，进入tcp_process_loss处理，此时frto开启，如果延迟的ack更新了una，则直接恢复loss状态。如果刚好等于重传包，这时候先发送新分片。</li>\n<li>3) 又一个新的ack到来，这时候由于没有重传包，延迟的ack会更新una，直接撤销丢包处理，离开LOSS状态。</li>\n</ul>\n<h1 id=\"3-2-frto恢复失败流程\"><a href=\"#3-2-frto恢复失败流程\" class=\"headerlink\" title=\"3.2 frto恢复失败流程\"></a>3.2 frto恢复失败流程</h1><ul>\n<li>1) RTO超时，发送新分片</li>\n<li>2) 收到一个ack，进入tcp_process_loss处理，此时frto开启，如上发送新分片。</li>\n<li>3) 又一个新的ack到来，这时候由于丢包，不更新对应的una，因此关闭frto，进入重传流程。</li>\n</ul>\n"},{"title":"TCP简介-读书笔记","date":"2017-03-19T12:00:38.000Z","_content":"\n@(Network)[tcp, congestion control]\n# 读书笔记-TCP简介\n本文主要记录阅读[linuxtcp][1]文章，其第二章中主要介绍了TCP拥塞控制的基础和一些发展历程，这里作为整理。\n\n个人理解，TCP的拥塞分为两部分，一部分是窗口值变化，慢启动和各种拥塞避免算法，这部分只尝试控制发往网络中的包的数量(拥塞窗口)，但是他并不处理是否丢包，是否应该重传，或者快速重传等；另一部分是TCP逐渐支持的一些机制，可以使tcp更好的进行网络状态的估计，不同的网络状态会对第一部分进行反馈，这部分属于框架级别(其实丢包重传和拥塞控制本身并没有完全相关性(比如固定丢包的链路，无线网络等)，但是由于长久以来的拥塞控制是基于丢包的，因此丢包作为网络拥塞状态判断，耦合在TCP的拥塞控制中，而由于丢包对拥塞控制的影响是毁灭性的，因此也在重传上做了较多的处理，来避免因为一些意外的丢包造成的影响，或者是提早避免因为网络拥塞导致的丢包)因此对应的tcp内核中，一部分对应的拥塞控制状态机，这里处理了所有tcp所支持的机制，如SACK,DSACK,FRTO等网络估计的基础，而拥塞避免则会根据猜测的网络状态进行合理控制。\n\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/简介1.png)\n\n\n[TOC]\n\n# 0. 参考资料\n\\[1\\] [linux_tcp](https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz)\n\\[2\\] [SACK](https://tools.ietf.org/html/rfc2018)\n\\[3\\] [Duplicate SACK](https://tools.ietf.org/html/rfc2883)\n\\[4\\] [Duplicate SACK ppt](https://www.eecis.udel.edu/~amer/856/sack.04f.ppt)\n\\[5\\] [FACK](http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf)\n\\[6\\] [FRTO-4138](https://tools.ietf.org/html/rfc4138)\n\\[7\\] [FRTO-5862](https://tools.ietf.org/html/rfc5682)\n\\[8\\] [FRTO-细节](http://blog.csdn.net/zhangskd/article/details/7446441)\n\\[9\\] [An Enhanced Recovery Algorithm for TCP Retransmission Timeouts\n](https://pdfs.semanticscholar.org/58b0/5b3f89481d2e84e136fe98d4236fea031226.pdf)\n\n# 1. 慢启动和拥塞避免\nTCP拥塞控制算法主要由发送端通过拥塞窗口(cwnd)来控制。最开始主要有两个拥塞控制的方法，通过阈值ssthresh来作为两种窗口增长的临界标志。\n\n- 慢启动：在小于阈值时，当每一个ack到来时，慢启动算法会将拥塞窗口增加一个segment大小。当你有cwnd个包发出，收到cwnd个ack，在慢启动阶段将会增加cwnd个窗口大小，是指数增长的过程。\n- 拥塞避免：当大于阈值后，拥塞避免算法会限制拥塞窗口在一个RTT内只增加一个segment大小。当你有cwnd个包发出，在这个RTT内收到cwnd个ack，在拥塞避免阶段每个ack增加(1 / 拥塞窗口大小)，窗口增加 (1 / cwnd) * cwnd = 1个大小。\n\n# 2. RTO\n重传可能被重传定时器RTO触发，RTO一旦超时，表明某个包丢失，对于TCP而言，丢包意味着网络产生拥塞，因此此时会把拥塞窗口降低到最小值(1个segment大小)。因此丢包是非常严苛的拥塞条件，一旦丢包发生，对整个传输效率会造成极大的影响。\n\n- In addition, when RTO occurs, the sender resets the congestion window to one segment, since the RTO may indicate that the network load has changed dramatically.\n\n- This is done because the packet loss is taken as an indication of congestion, and the sender needs to reduce its transmission rate to alleviate the network congestion.\n\n# 3. RTT与重传二义性\n由于RTO本身对于TCP性能而言非常严苛，因此RTO使用的定时器时间是否能准确反映网络实际传输情况对于TCP而言非常重要。比如链路RTT突然增加了，但是用于RTO的RTT仍然是之前的小值，这样可能会导致数据虽然没有丢包，但是交往较慢，RTO触发过于频繁，再由于丢包对于TCP的影响，会导致TCP窗口衰减剧烈。\n\n但是TCP对于普通包和重传包使用相同的sequence number，因此当ack到来时，无法区分这个ack对应的是普通包的还是重传包的，因此此时用这个ack的时间戳选项来计算链路RTT可能会导致各种问题。\n\n因此当前使用的RTT计算公式一般是smooth rtt计算。\n\n# 4. 快速重传和快速恢复\n由于丢包属于一类重大事故，因此TCP中总是需要尝试提前发现，在其形成重大事故(重置cwnd)前将其提前识别。因此当接收端收到乱序包时，会发送期待的包的序号ack，当发送端收到两个重复的ack时，会发现出现乱序(状态机中的Disorder)，并尝试进行重传来恢复这个包，以免RTO超时触发。当发送端收到三个重复的ack时，会进入快速恢复(状态机中的Recovery)，认为网络可能存在一定的拥塞，会降低拥塞窗口(但是不会像RTO触发以后那样激进)。两种状态下，都会恢复认为丢失或者乱序的包，直到收到非重复的ack为止。\n\n# 5. 显式拥塞控制\n由于TCP本身并无法感知到整个网络链路的质量，因此基本是基于自己的算法和丢包反馈来进行拥塞判断，本身存在一定的局限性。\n\n后来的一些路由器在处理数据包，可能可以感知到网络是否真正拥塞，当路由器感知到拥塞时，会通过设置TCP标志位的ECE给TCP，TCP发送端收到带有ECE的ack时会进入拥塞状态(状态机中的CWR)，同时发送一个携带标志位CWR的包给接收端，表示自己当前正在衰减拥塞窗口。\n\n# 6. Selective acknowledgements\n由于进入乱序或者快速重传后，在一个RTT之内只能处理一个异常包(不会发送新的包直到新的ack到来，但是当丢包是不连续的若干个，恢复完后仍然会进入对应状态，单独处理下一个乱序丢包，如发送端发送1-6，接收端先收到1，3，6，这时候发送先恢复包2，恢复完包2收到ack发现乱序，请求包4，发送端再恢复4，恢复后发现仍然乱序，请求包5，再次单独恢复包5)，因此在恢复阶段严重影响吞吐量。\n\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/tcp_recovery_multi_loss.png)\n\nSACK并没有打破原有的ack机制，只是在其ack机制上，在TCP option字段中附加了额外信息。<sup>[4]</sup>\n\n例子如下图：\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/sack.png)\n\n- Multiple packet losses from a window of data can have a catastrophic effect on TCP throughput.\n\n- SACK does not change the meaning of ACK field.\n\n注: SACK附加在TCP option字段中，option字段最多只有40字节，因此SACK最多包含四个区间。\n\n- A SACK option that specifies n blocks will have a length of 8*n+2 bytes, so the 40 bytes available for TCP options can specify a   maximum of 4 blocks.\n\n注2: SACK必须接收和发送端都支持才可以正常使用。\n\n# 7. Duplicate-SACK\nSACK在rfc 2018定义的时候，并没有声明其收到两个相同的包以后的处理。D-SACK会使接收端发送重复块的信息给发送端。\n\n简单流程如下：\n当DSACK激活时，最后一个ACK中的SACK第一个区域为重复区域，不同于普通SACK，它是已经收到的区域的一个子区间，每个重复块只会上报一次。\n\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/dsack.png)\n\n\n# 8. Forward Acknowledgements\nForward Acknowledgement是基于SACK的相关的拥塞控制算法。\n\n当拥塞发生时，此时已经发生丢包，这时候会引入新的变量fackets\\_out来统计SACK中的数据量，并根据当前已经发送的数据量una和重传数据量retran来估算本条连接实际在网络中的包数量(总包数 - 已经ACK的数量 + 重传包)。并根据这个数值和拥塞窗口进行比较，如果当前网络中的包数量小于拥塞窗口，说明仍然可以往网络中发送部分数量的包。\n\n这种算法本质上是对网络中的包数量进行更精确的估计，结合DSACK，可以更精准的进行判断，可以在恢复阶段依旧保持一定的速率，在处理乱序包的时候可以比传统TCP更加激进。\n\n# 9. FRTO\n\n当网络链路存在一些突发的特殊场景时，可能会触发超时定时器，由于TCP对于丢包的处理异常严格，可能会造成链路质量下降。\n\n可能的一些场景：\n- 对于移动信号的跨域处理，可能会造成突发的延迟。\n- 对于低带宽链路，偶发的竞争可能也会造成整个RTT的增加。\n- 稳定的链路上可能也有一些原因导致某些包及其重传老是失败。\n\n- First, some mobile networking technologies involve sudden delay spikes on transmission because of actions taken during a hand-off.  \n- Second, given a low-bandwidth link or some other change in available bandwidth, arrival of competing traffic (possibly with higher priority) can cause a sudden increase of round-trip time. This may trigger a spurious retransmission timeout. \n- A persistently reliable link layer can also cause a sudden delay when a data frame and several retransmissions of it are lost for some reason.\n\n可能造成的一些影响：\n\n- 虚假超时后的慢启动可能会导致向已经产生拥塞的网络中注入更多的数据包，会严重影响实际网络的拥塞状态。\n- 当虚假超时触发后，可能造成虚假重传，当过多虚假重传发生后，对应的ack回来时可能会触发虚假的快速恢复，如下图，第二次虚假的快速重传是由于第一次虚假RTO超时导致重传发送了重复包导致。\n\n- However, if the RTO occurs spuriously and there still are segments outstanding in the network, a false slow start is harmful for the potentially congested network as it injects extra segments to the network at increasing rate.\n\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/frto.png)\n\nFRTO会在RTO超时后，不会类似传统TCP的超时机制，会额外根据后续两个ACK与当前未确认的最小包进行比较，根据这个结果判断当前RTO是否在安全范围内。  \n如果收到的是未确认的包之后的包，则可能是因为网络原因导致的延迟，可以进入恢复状态。\n如果收到的是重复的ack，则认为这个包确实已经丢失，进入丢包状态。\n\n# 10. 概览图\n\n简单用图画出之间衍生的关系。  \n\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/概览.png)\n\n\n[1]: https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz\n[2]: https://tools.ietf.org/html/rfc2018\n[3]: https://tools.ietf.org/html/rfc2883\n[4]: https://www.eecis.udel.edu/~amer/856/sack.04f.ppt\n[5]: http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf\n[6]: https://tools.ietf.org/html/rfc4138\n[7]: https://tools.ietf.org/html/rfc5682\n[8]: http://blog.csdn.net/zhangskd/article/details/7446441\n[9]: https://pdfs.semanticscholar.org/58b0/5b3f89481d2e84e136fe98d4236fea031226.pdf\n","source":"_posts/TCP简介-读书笔记.md","raw":"---\ntitle: TCP简介-读书笔记\ndate: 2017-03-19 20:00:38\ntags: [TCP, linux, 读书笔记, 拥塞控制]\n---\n\n@(Network)[tcp, congestion control]\n# 读书笔记-TCP简介\n本文主要记录阅读[linuxtcp][1]文章，其第二章中主要介绍了TCP拥塞控制的基础和一些发展历程，这里作为整理。\n\n个人理解，TCP的拥塞分为两部分，一部分是窗口值变化，慢启动和各种拥塞避免算法，这部分只尝试控制发往网络中的包的数量(拥塞窗口)，但是他并不处理是否丢包，是否应该重传，或者快速重传等；另一部分是TCP逐渐支持的一些机制，可以使tcp更好的进行网络状态的估计，不同的网络状态会对第一部分进行反馈，这部分属于框架级别(其实丢包重传和拥塞控制本身并没有完全相关性(比如固定丢包的链路，无线网络等)，但是由于长久以来的拥塞控制是基于丢包的，因此丢包作为网络拥塞状态判断，耦合在TCP的拥塞控制中，而由于丢包对拥塞控制的影响是毁灭性的，因此也在重传上做了较多的处理，来避免因为一些意外的丢包造成的影响，或者是提早避免因为网络拥塞导致的丢包)因此对应的tcp内核中，一部分对应的拥塞控制状态机，这里处理了所有tcp所支持的机制，如SACK,DSACK,FRTO等网络估计的基础，而拥塞避免则会根据猜测的网络状态进行合理控制。\n\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/简介1.png)\n\n\n[TOC]\n\n# 0. 参考资料\n\\[1\\] [linux_tcp](https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz)\n\\[2\\] [SACK](https://tools.ietf.org/html/rfc2018)\n\\[3\\] [Duplicate SACK](https://tools.ietf.org/html/rfc2883)\n\\[4\\] [Duplicate SACK ppt](https://www.eecis.udel.edu/~amer/856/sack.04f.ppt)\n\\[5\\] [FACK](http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf)\n\\[6\\] [FRTO-4138](https://tools.ietf.org/html/rfc4138)\n\\[7\\] [FRTO-5862](https://tools.ietf.org/html/rfc5682)\n\\[8\\] [FRTO-细节](http://blog.csdn.net/zhangskd/article/details/7446441)\n\\[9\\] [An Enhanced Recovery Algorithm for TCP Retransmission Timeouts\n](https://pdfs.semanticscholar.org/58b0/5b3f89481d2e84e136fe98d4236fea031226.pdf)\n\n# 1. 慢启动和拥塞避免\nTCP拥塞控制算法主要由发送端通过拥塞窗口(cwnd)来控制。最开始主要有两个拥塞控制的方法，通过阈值ssthresh来作为两种窗口增长的临界标志。\n\n- 慢启动：在小于阈值时，当每一个ack到来时，慢启动算法会将拥塞窗口增加一个segment大小。当你有cwnd个包发出，收到cwnd个ack，在慢启动阶段将会增加cwnd个窗口大小，是指数增长的过程。\n- 拥塞避免：当大于阈值后，拥塞避免算法会限制拥塞窗口在一个RTT内只增加一个segment大小。当你有cwnd个包发出，在这个RTT内收到cwnd个ack，在拥塞避免阶段每个ack增加(1 / 拥塞窗口大小)，窗口增加 (1 / cwnd) * cwnd = 1个大小。\n\n# 2. RTO\n重传可能被重传定时器RTO触发，RTO一旦超时，表明某个包丢失，对于TCP而言，丢包意味着网络产生拥塞，因此此时会把拥塞窗口降低到最小值(1个segment大小)。因此丢包是非常严苛的拥塞条件，一旦丢包发生，对整个传输效率会造成极大的影响。\n\n- In addition, when RTO occurs, the sender resets the congestion window to one segment, since the RTO may indicate that the network load has changed dramatically.\n\n- This is done because the packet loss is taken as an indication of congestion, and the sender needs to reduce its transmission rate to alleviate the network congestion.\n\n# 3. RTT与重传二义性\n由于RTO本身对于TCP性能而言非常严苛，因此RTO使用的定时器时间是否能准确反映网络实际传输情况对于TCP而言非常重要。比如链路RTT突然增加了，但是用于RTO的RTT仍然是之前的小值，这样可能会导致数据虽然没有丢包，但是交往较慢，RTO触发过于频繁，再由于丢包对于TCP的影响，会导致TCP窗口衰减剧烈。\n\n但是TCP对于普通包和重传包使用相同的sequence number，因此当ack到来时，无法区分这个ack对应的是普通包的还是重传包的，因此此时用这个ack的时间戳选项来计算链路RTT可能会导致各种问题。\n\n因此当前使用的RTT计算公式一般是smooth rtt计算。\n\n# 4. 快速重传和快速恢复\n由于丢包属于一类重大事故，因此TCP中总是需要尝试提前发现，在其形成重大事故(重置cwnd)前将其提前识别。因此当接收端收到乱序包时，会发送期待的包的序号ack，当发送端收到两个重复的ack时，会发现出现乱序(状态机中的Disorder)，并尝试进行重传来恢复这个包，以免RTO超时触发。当发送端收到三个重复的ack时，会进入快速恢复(状态机中的Recovery)，认为网络可能存在一定的拥塞，会降低拥塞窗口(但是不会像RTO触发以后那样激进)。两种状态下，都会恢复认为丢失或者乱序的包，直到收到非重复的ack为止。\n\n# 5. 显式拥塞控制\n由于TCP本身并无法感知到整个网络链路的质量，因此基本是基于自己的算法和丢包反馈来进行拥塞判断，本身存在一定的局限性。\n\n后来的一些路由器在处理数据包，可能可以感知到网络是否真正拥塞，当路由器感知到拥塞时，会通过设置TCP标志位的ECE给TCP，TCP发送端收到带有ECE的ack时会进入拥塞状态(状态机中的CWR)，同时发送一个携带标志位CWR的包给接收端，表示自己当前正在衰减拥塞窗口。\n\n# 6. Selective acknowledgements\n由于进入乱序或者快速重传后，在一个RTT之内只能处理一个异常包(不会发送新的包直到新的ack到来，但是当丢包是不连续的若干个，恢复完后仍然会进入对应状态，单独处理下一个乱序丢包，如发送端发送1-6，接收端先收到1，3，6，这时候发送先恢复包2，恢复完包2收到ack发现乱序，请求包4，发送端再恢复4，恢复后发现仍然乱序，请求包5，再次单独恢复包5)，因此在恢复阶段严重影响吞吐量。\n\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/tcp_recovery_multi_loss.png)\n\nSACK并没有打破原有的ack机制，只是在其ack机制上，在TCP option字段中附加了额外信息。<sup>[4]</sup>\n\n例子如下图：\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/sack.png)\n\n- Multiple packet losses from a window of data can have a catastrophic effect on TCP throughput.\n\n- SACK does not change the meaning of ACK field.\n\n注: SACK附加在TCP option字段中，option字段最多只有40字节，因此SACK最多包含四个区间。\n\n- A SACK option that specifies n blocks will have a length of 8*n+2 bytes, so the 40 bytes available for TCP options can specify a   maximum of 4 blocks.\n\n注2: SACK必须接收和发送端都支持才可以正常使用。\n\n# 7. Duplicate-SACK\nSACK在rfc 2018定义的时候，并没有声明其收到两个相同的包以后的处理。D-SACK会使接收端发送重复块的信息给发送端。\n\n简单流程如下：\n当DSACK激活时，最后一个ACK中的SACK第一个区域为重复区域，不同于普通SACK，它是已经收到的区域的一个子区间，每个重复块只会上报一次。\n\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/dsack.png)\n\n\n# 8. Forward Acknowledgements\nForward Acknowledgement是基于SACK的相关的拥塞控制算法。\n\n当拥塞发生时，此时已经发生丢包，这时候会引入新的变量fackets\\_out来统计SACK中的数据量，并根据当前已经发送的数据量una和重传数据量retran来估算本条连接实际在网络中的包数量(总包数 - 已经ACK的数量 + 重传包)。并根据这个数值和拥塞窗口进行比较，如果当前网络中的包数量小于拥塞窗口，说明仍然可以往网络中发送部分数量的包。\n\n这种算法本质上是对网络中的包数量进行更精确的估计，结合DSACK，可以更精准的进行判断，可以在恢复阶段依旧保持一定的速率，在处理乱序包的时候可以比传统TCP更加激进。\n\n# 9. FRTO\n\n当网络链路存在一些突发的特殊场景时，可能会触发超时定时器，由于TCP对于丢包的处理异常严格，可能会造成链路质量下降。\n\n可能的一些场景：\n- 对于移动信号的跨域处理，可能会造成突发的延迟。\n- 对于低带宽链路，偶发的竞争可能也会造成整个RTT的增加。\n- 稳定的链路上可能也有一些原因导致某些包及其重传老是失败。\n\n- First, some mobile networking technologies involve sudden delay spikes on transmission because of actions taken during a hand-off.  \n- Second, given a low-bandwidth link or some other change in available bandwidth, arrival of competing traffic (possibly with higher priority) can cause a sudden increase of round-trip time. This may trigger a spurious retransmission timeout. \n- A persistently reliable link layer can also cause a sudden delay when a data frame and several retransmissions of it are lost for some reason.\n\n可能造成的一些影响：\n\n- 虚假超时后的慢启动可能会导致向已经产生拥塞的网络中注入更多的数据包，会严重影响实际网络的拥塞状态。\n- 当虚假超时触发后，可能造成虚假重传，当过多虚假重传发生后，对应的ack回来时可能会触发虚假的快速恢复，如下图，第二次虚假的快速重传是由于第一次虚假RTO超时导致重传发送了重复包导致。\n\n- However, if the RTO occurs spuriously and there still are segments outstanding in the network, a false slow start is harmful for the potentially congested network as it injects extra segments to the network at increasing rate.\n\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/frto.png)\n\nFRTO会在RTO超时后，不会类似传统TCP的超时机制，会额外根据后续两个ACK与当前未确认的最小包进行比较，根据这个结果判断当前RTO是否在安全范围内。  \n如果收到的是未确认的包之后的包，则可能是因为网络原因导致的延迟，可以进入恢复状态。\n如果收到的是重复的ack，则认为这个包确实已经丢失，进入丢包状态。\n\n# 10. 概览图\n\n简单用图画出之间衍生的关系。  \n\n![Alt text](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/概览.png)\n\n\n[1]: https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz\n[2]: https://tools.ietf.org/html/rfc2018\n[3]: https://tools.ietf.org/html/rfc2883\n[4]: https://www.eecis.udel.edu/~amer/856/sack.04f.ppt\n[5]: http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf\n[6]: https://tools.ietf.org/html/rfc4138\n[7]: https://tools.ietf.org/html/rfc5682\n[8]: http://blog.csdn.net/zhangskd/article/details/7446441\n[9]: https://pdfs.semanticscholar.org/58b0/5b3f89481d2e84e136fe98d4236fea031226.pdf\n","slug":"TCP简介-读书笔记","published":1,"updated":"2017-04-06T13:56:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gzs4jt0006r8c3tgsnlifo","content":"<p>@(Network)[tcp, congestion control]</p>\n<h1 id=\"读书笔记-TCP简介\"><a href=\"#读书笔记-TCP简介\" class=\"headerlink\" title=\"读书笔记-TCP简介\"></a>读书笔记-TCP简介</h1><p>本文主要记录阅读<a href=\"https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz\" target=\"_blank\" rel=\"external\">linuxtcp</a>文章，其第二章中主要介绍了TCP拥塞控制的基础和一些发展历程，这里作为整理。</p>\n<p>个人理解，TCP的拥塞分为两部分，一部分是窗口值变化，慢启动和各种拥塞避免算法，这部分只尝试控制发往网络中的包的数量(拥塞窗口)，但是他并不处理是否丢包，是否应该重传，或者快速重传等；另一部分是TCP逐渐支持的一些机制，可以使tcp更好的进行网络状态的估计，不同的网络状态会对第一部分进行反馈，这部分属于框架级别(其实丢包重传和拥塞控制本身并没有完全相关性(比如固定丢包的链路，无线网络等)，但是由于长久以来的拥塞控制是基于丢包的，因此丢包作为网络拥塞状态判断，耦合在TCP的拥塞控制中，而由于丢包对拥塞控制的影响是毁灭性的，因此也在重传上做了较多的处理，来避免因为一些意外的丢包造成的影响，或者是提早避免因为网络拥塞导致的丢包)因此对应的tcp内核中，一部分对应的拥塞控制状态机，这里处理了所有tcp所支持的机制，如SACK,DSACK,FRTO等网络估计的基础，而拥塞避免则会根据猜测的网络状态进行合理控制。</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/简介1.png\" alt=\"Alt text\"></p>\n<p>[TOC]</p>\n<h1 id=\"0-参考资料\"><a href=\"#0-参考资料\" class=\"headerlink\" title=\"0. 参考资料\"></a>0. 参考资料</h1><p>[1] <a href=\"https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz\" target=\"_blank\" rel=\"external\">linux_tcp</a><br>[2] <a href=\"https://tools.ietf.org/html/rfc2018\" target=\"_blank\" rel=\"external\">SACK</a><br>[3] <a href=\"https://tools.ietf.org/html/rfc2883\" target=\"_blank\" rel=\"external\">Duplicate SACK</a><br>[4] <a href=\"https://www.eecis.udel.edu/~amer/856/sack.04f.ppt\" target=\"_blank\" rel=\"external\">Duplicate SACK ppt</a><br>[5] <a href=\"http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf\" target=\"_blank\" rel=\"external\">FACK</a><br>[6] <a href=\"https://tools.ietf.org/html/rfc4138\" target=\"_blank\" rel=\"external\">FRTO-4138</a><br>[7] <a href=\"https://tools.ietf.org/html/rfc5682\" target=\"_blank\" rel=\"external\">FRTO-5862</a><br>[8] <a href=\"http://blog.csdn.net/zhangskd/article/details/7446441\" target=\"_blank\" rel=\"external\">FRTO-细节</a><br>[9] <a href=\"https://pdfs.semanticscholar.org/58b0/5b3f89481d2e84e136fe98d4236fea031226.pdf\" target=\"_blank\" rel=\"external\">An Enhanced Recovery Algorithm for TCP Retransmission Timeouts\n</a></p>\n<h1 id=\"1-慢启动和拥塞避免\"><a href=\"#1-慢启动和拥塞避免\" class=\"headerlink\" title=\"1. 慢启动和拥塞避免\"></a>1. 慢启动和拥塞避免</h1><p>TCP拥塞控制算法主要由发送端通过拥塞窗口(cwnd)来控制。最开始主要有两个拥塞控制的方法，通过阈值ssthresh来作为两种窗口增长的临界标志。</p>\n<ul>\n<li>慢启动：在小于阈值时，当每一个ack到来时，慢启动算法会将拥塞窗口增加一个segment大小。当你有cwnd个包发出，收到cwnd个ack，在慢启动阶段将会增加cwnd个窗口大小，是指数增长的过程。</li>\n<li>拥塞避免：当大于阈值后，拥塞避免算法会限制拥塞窗口在一个RTT内只增加一个segment大小。当你有cwnd个包发出，在这个RTT内收到cwnd个ack，在拥塞避免阶段每个ack增加(1 / 拥塞窗口大小)，窗口增加 (1 / cwnd) * cwnd = 1个大小。</li>\n</ul>\n<h1 id=\"2-RTO\"><a href=\"#2-RTO\" class=\"headerlink\" title=\"2. RTO\"></a>2. RTO</h1><p>重传可能被重传定时器RTO触发，RTO一旦超时，表明某个包丢失，对于TCP而言，丢包意味着网络产生拥塞，因此此时会把拥塞窗口降低到最小值(1个segment大小)。因此丢包是非常严苛的拥塞条件，一旦丢包发生，对整个传输效率会造成极大的影响。</p>\n<ul>\n<li><p>In addition, when RTO occurs, the sender resets the congestion window to one segment, since the RTO may indicate that the network load has changed dramatically.</p>\n</li>\n<li><p>This is done because the packet loss is taken as an indication of congestion, and the sender needs to reduce its transmission rate to alleviate the network congestion.</p>\n</li>\n</ul>\n<h1 id=\"3-RTT与重传二义性\"><a href=\"#3-RTT与重传二义性\" class=\"headerlink\" title=\"3. RTT与重传二义性\"></a>3. RTT与重传二义性</h1><p>由于RTO本身对于TCP性能而言非常严苛，因此RTO使用的定时器时间是否能准确反映网络实际传输情况对于TCP而言非常重要。比如链路RTT突然增加了，但是用于RTO的RTT仍然是之前的小值，这样可能会导致数据虽然没有丢包，但是交往较慢，RTO触发过于频繁，再由于丢包对于TCP的影响，会导致TCP窗口衰减剧烈。</p>\n<p>但是TCP对于普通包和重传包使用相同的sequence number，因此当ack到来时，无法区分这个ack对应的是普通包的还是重传包的，因此此时用这个ack的时间戳选项来计算链路RTT可能会导致各种问题。</p>\n<p>因此当前使用的RTT计算公式一般是smooth rtt计算。</p>\n<h1 id=\"4-快速重传和快速恢复\"><a href=\"#4-快速重传和快速恢复\" class=\"headerlink\" title=\"4. 快速重传和快速恢复\"></a>4. 快速重传和快速恢复</h1><p>由于丢包属于一类重大事故，因此TCP中总是需要尝试提前发现，在其形成重大事故(重置cwnd)前将其提前识别。因此当接收端收到乱序包时，会发送期待的包的序号ack，当发送端收到两个重复的ack时，会发现出现乱序(状态机中的Disorder)，并尝试进行重传来恢复这个包，以免RTO超时触发。当发送端收到三个重复的ack时，会进入快速恢复(状态机中的Recovery)，认为网络可能存在一定的拥塞，会降低拥塞窗口(但是不会像RTO触发以后那样激进)。两种状态下，都会恢复认为丢失或者乱序的包，直到收到非重复的ack为止。</p>\n<h1 id=\"5-显式拥塞控制\"><a href=\"#5-显式拥塞控制\" class=\"headerlink\" title=\"5. 显式拥塞控制\"></a>5. 显式拥塞控制</h1><p>由于TCP本身并无法感知到整个网络链路的质量，因此基本是基于自己的算法和丢包反馈来进行拥塞判断，本身存在一定的局限性。</p>\n<p>后来的一些路由器在处理数据包，可能可以感知到网络是否真正拥塞，当路由器感知到拥塞时，会通过设置TCP标志位的ECE给TCP，TCP发送端收到带有ECE的ack时会进入拥塞状态(状态机中的CWR)，同时发送一个携带标志位CWR的包给接收端，表示自己当前正在衰减拥塞窗口。</p>\n<h1 id=\"6-Selective-acknowledgements\"><a href=\"#6-Selective-acknowledgements\" class=\"headerlink\" title=\"6. Selective acknowledgements\"></a>6. Selective acknowledgements</h1><p>由于进入乱序或者快速重传后，在一个RTT之内只能处理一个异常包(不会发送新的包直到新的ack到来，但是当丢包是不连续的若干个，恢复完后仍然会进入对应状态，单独处理下一个乱序丢包，如发送端发送1-6，接收端先收到1，3，6，这时候发送先恢复包2，恢复完包2收到ack发现乱序，请求包4，发送端再恢复4，恢复后发现仍然乱序，请求包5，再次单独恢复包5)，因此在恢复阶段严重影响吞吐量。</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/tcp_recovery_multi_loss.png\" alt=\"Alt text\"></p>\n<p>SACK并没有打破原有的ack机制，只是在其ack机制上，在TCP option字段中附加了额外信息。<sup><a href=\"https://www.eecis.udel.edu/~amer/856/sack.04f.ppt\" target=\"_blank\" rel=\"external\">4</a></sup></p>\n<p>例子如下图：<br><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/sack.png\" alt=\"Alt text\"></p>\n<ul>\n<li><p>Multiple packet losses from a window of data can have a catastrophic effect on TCP throughput.</p>\n</li>\n<li><p>SACK does not change the meaning of ACK field.</p>\n</li>\n</ul>\n<p>注: SACK附加在TCP option字段中，option字段最多只有40字节，因此SACK最多包含四个区间。</p>\n<ul>\n<li>A SACK option that specifies n blocks will have a length of 8*n+2 bytes, so the 40 bytes available for TCP options can specify a   maximum of 4 blocks.</li>\n</ul>\n<p>注2: SACK必须接收和发送端都支持才可以正常使用。</p>\n<h1 id=\"7-Duplicate-SACK\"><a href=\"#7-Duplicate-SACK\" class=\"headerlink\" title=\"7. Duplicate-SACK\"></a>7. Duplicate-SACK</h1><p>SACK在rfc 2018定义的时候，并没有声明其收到两个相同的包以后的处理。D-SACK会使接收端发送重复块的信息给发送端。</p>\n<p>简单流程如下：<br>当DSACK激活时，最后一个ACK中的SACK第一个区域为重复区域，不同于普通SACK，它是已经收到的区域的一个子区间，每个重复块只会上报一次。</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/dsack.png\" alt=\"Alt text\"></p>\n<h1 id=\"8-Forward-Acknowledgements\"><a href=\"#8-Forward-Acknowledgements\" class=\"headerlink\" title=\"8. Forward Acknowledgements\"></a>8. Forward Acknowledgements</h1><p>Forward Acknowledgement是基于SACK的相关的拥塞控制算法。</p>\n<p>当拥塞发生时，此时已经发生丢包，这时候会引入新的变量fackets_out来统计SACK中的数据量，并根据当前已经发送的数据量una和重传数据量retran来估算本条连接实际在网络中的包数量(总包数 - 已经ACK的数量 + 重传包)。并根据这个数值和拥塞窗口进行比较，如果当前网络中的包数量小于拥塞窗口，说明仍然可以往网络中发送部分数量的包。</p>\n<p>这种算法本质上是对网络中的包数量进行更精确的估计，结合DSACK，可以更精准的进行判断，可以在恢复阶段依旧保持一定的速率，在处理乱序包的时候可以比传统TCP更加激进。</p>\n<h1 id=\"9-FRTO\"><a href=\"#9-FRTO\" class=\"headerlink\" title=\"9. FRTO\"></a>9. FRTO</h1><p>当网络链路存在一些突发的特殊场景时，可能会触发超时定时器，由于TCP对于丢包的处理异常严格，可能会造成链路质量下降。</p>\n<p>可能的一些场景：</p>\n<ul>\n<li>对于移动信号的跨域处理，可能会造成突发的延迟。</li>\n<li>对于低带宽链路，偶发的竞争可能也会造成整个RTT的增加。</li>\n<li><p>稳定的链路上可能也有一些原因导致某些包及其重传老是失败。</p>\n</li>\n<li><p>First, some mobile networking technologies involve sudden delay spikes on transmission because of actions taken during a hand-off.  </p>\n</li>\n<li>Second, given a low-bandwidth link or some other change in available bandwidth, arrival of competing traffic (possibly with higher priority) can cause a sudden increase of round-trip time. This may trigger a spurious retransmission timeout. </li>\n<li>A persistently reliable link layer can also cause a sudden delay when a data frame and several retransmissions of it are lost for some reason.</li>\n</ul>\n<p>可能造成的一些影响：</p>\n<ul>\n<li>虚假超时后的慢启动可能会导致向已经产生拥塞的网络中注入更多的数据包，会严重影响实际网络的拥塞状态。</li>\n<li><p>当虚假超时触发后，可能造成虚假重传，当过多虚假重传发生后，对应的ack回来时可能会触发虚假的快速恢复，如下图，第二次虚假的快速重传是由于第一次虚假RTO超时导致重传发送了重复包导致。</p>\n</li>\n<li><p>However, if the RTO occurs spuriously and there still are segments outstanding in the network, a false slow start is harmful for the potentially congested network as it injects extra segments to the network at increasing rate.</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/frto.png\" alt=\"Alt text\"></p>\n<p>FRTO会在RTO超时后，不会类似传统TCP的超时机制，会额外根据后续两个ACK与当前未确认的最小包进行比较，根据这个结果判断当前RTO是否在安全范围内。<br>如果收到的是未确认的包之后的包，则可能是因为网络原因导致的延迟，可以进入恢复状态。<br>如果收到的是重复的ack，则认为这个包确实已经丢失，进入丢包状态。</p>\n<h1 id=\"10-概览图\"><a href=\"#10-概览图\" class=\"headerlink\" title=\"10. 概览图\"></a>10. 概览图</h1><p>简单用图画出之间衍生的关系。  </p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/概览.png\" alt=\"Alt text\"></p>\n","excerpt":"","more":"<p>@(Network)[tcp, congestion control]</p>\n<h1 id=\"读书笔记-TCP简介\"><a href=\"#读书笔记-TCP简介\" class=\"headerlink\" title=\"读书笔记-TCP简介\"></a>读书笔记-TCP简介</h1><p>本文主要记录阅读<a href=\"https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz\">linuxtcp</a>文章，其第二章中主要介绍了TCP拥塞控制的基础和一些发展历程，这里作为整理。</p>\n<p>个人理解，TCP的拥塞分为两部分，一部分是窗口值变化，慢启动和各种拥塞避免算法，这部分只尝试控制发往网络中的包的数量(拥塞窗口)，但是他并不处理是否丢包，是否应该重传，或者快速重传等；另一部分是TCP逐渐支持的一些机制，可以使tcp更好的进行网络状态的估计，不同的网络状态会对第一部分进行反馈，这部分属于框架级别(其实丢包重传和拥塞控制本身并没有完全相关性(比如固定丢包的链路，无线网络等)，但是由于长久以来的拥塞控制是基于丢包的，因此丢包作为网络拥塞状态判断，耦合在TCP的拥塞控制中，而由于丢包对拥塞控制的影响是毁灭性的，因此也在重传上做了较多的处理，来避免因为一些意外的丢包造成的影响，或者是提早避免因为网络拥塞导致的丢包)因此对应的tcp内核中，一部分对应的拥塞控制状态机，这里处理了所有tcp所支持的机制，如SACK,DSACK,FRTO等网络估计的基础，而拥塞避免则会根据猜测的网络状态进行合理控制。</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/简介1.png\" alt=\"Alt text\"></p>\n<p>[TOC]</p>\n<h1 id=\"0-参考资料\"><a href=\"#0-参考资料\" class=\"headerlink\" title=\"0. 参考资料\"></a>0. 参考资料</h1><p>[1] <a href=\"https://www.cs.helsinki.fi/group/iwtcp/papers/linuxtcp.ps.gz\">linux_tcp</a><br>[2] <a href=\"https://tools.ietf.org/html/rfc2018\">SACK</a><br>[3] <a href=\"https://tools.ietf.org/html/rfc2883\">Duplicate SACK</a><br>[4] <a href=\"https://www.eecis.udel.edu/~amer/856/sack.04f.ppt\">Duplicate SACK ppt</a><br>[5] <a href=\"http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf\">FACK</a><br>[6] <a href=\"https://tools.ietf.org/html/rfc4138\">FRTO-4138</a><br>[7] <a href=\"https://tools.ietf.org/html/rfc5682\">FRTO-5862</a><br>[8] <a href=\"http://blog.csdn.net/zhangskd/article/details/7446441\">FRTO-细节</a><br>[9] <a href=\"https://pdfs.semanticscholar.org/58b0/5b3f89481d2e84e136fe98d4236fea031226.pdf\">An Enhanced Recovery Algorithm for TCP Retransmission Timeouts\n</a></p>\n<h1 id=\"1-慢启动和拥塞避免\"><a href=\"#1-慢启动和拥塞避免\" class=\"headerlink\" title=\"1. 慢启动和拥塞避免\"></a>1. 慢启动和拥塞避免</h1><p>TCP拥塞控制算法主要由发送端通过拥塞窗口(cwnd)来控制。最开始主要有两个拥塞控制的方法，通过阈值ssthresh来作为两种窗口增长的临界标志。</p>\n<ul>\n<li>慢启动：在小于阈值时，当每一个ack到来时，慢启动算法会将拥塞窗口增加一个segment大小。当你有cwnd个包发出，收到cwnd个ack，在慢启动阶段将会增加cwnd个窗口大小，是指数增长的过程。</li>\n<li>拥塞避免：当大于阈值后，拥塞避免算法会限制拥塞窗口在一个RTT内只增加一个segment大小。当你有cwnd个包发出，在这个RTT内收到cwnd个ack，在拥塞避免阶段每个ack增加(1 / 拥塞窗口大小)，窗口增加 (1 / cwnd) * cwnd = 1个大小。</li>\n</ul>\n<h1 id=\"2-RTO\"><a href=\"#2-RTO\" class=\"headerlink\" title=\"2. RTO\"></a>2. RTO</h1><p>重传可能被重传定时器RTO触发，RTO一旦超时，表明某个包丢失，对于TCP而言，丢包意味着网络产生拥塞，因此此时会把拥塞窗口降低到最小值(1个segment大小)。因此丢包是非常严苛的拥塞条件，一旦丢包发生，对整个传输效率会造成极大的影响。</p>\n<ul>\n<li><p>In addition, when RTO occurs, the sender resets the congestion window to one segment, since the RTO may indicate that the network load has changed dramatically.</p>\n</li>\n<li><p>This is done because the packet loss is taken as an indication of congestion, and the sender needs to reduce its transmission rate to alleviate the network congestion.</p>\n</li>\n</ul>\n<h1 id=\"3-RTT与重传二义性\"><a href=\"#3-RTT与重传二义性\" class=\"headerlink\" title=\"3. RTT与重传二义性\"></a>3. RTT与重传二义性</h1><p>由于RTO本身对于TCP性能而言非常严苛，因此RTO使用的定时器时间是否能准确反映网络实际传输情况对于TCP而言非常重要。比如链路RTT突然增加了，但是用于RTO的RTT仍然是之前的小值，这样可能会导致数据虽然没有丢包，但是交往较慢，RTO触发过于频繁，再由于丢包对于TCP的影响，会导致TCP窗口衰减剧烈。</p>\n<p>但是TCP对于普通包和重传包使用相同的sequence number，因此当ack到来时，无法区分这个ack对应的是普通包的还是重传包的，因此此时用这个ack的时间戳选项来计算链路RTT可能会导致各种问题。</p>\n<p>因此当前使用的RTT计算公式一般是smooth rtt计算。</p>\n<h1 id=\"4-快速重传和快速恢复\"><a href=\"#4-快速重传和快速恢复\" class=\"headerlink\" title=\"4. 快速重传和快速恢复\"></a>4. 快速重传和快速恢复</h1><p>由于丢包属于一类重大事故，因此TCP中总是需要尝试提前发现，在其形成重大事故(重置cwnd)前将其提前识别。因此当接收端收到乱序包时，会发送期待的包的序号ack，当发送端收到两个重复的ack时，会发现出现乱序(状态机中的Disorder)，并尝试进行重传来恢复这个包，以免RTO超时触发。当发送端收到三个重复的ack时，会进入快速恢复(状态机中的Recovery)，认为网络可能存在一定的拥塞，会降低拥塞窗口(但是不会像RTO触发以后那样激进)。两种状态下，都会恢复认为丢失或者乱序的包，直到收到非重复的ack为止。</p>\n<h1 id=\"5-显式拥塞控制\"><a href=\"#5-显式拥塞控制\" class=\"headerlink\" title=\"5. 显式拥塞控制\"></a>5. 显式拥塞控制</h1><p>由于TCP本身并无法感知到整个网络链路的质量，因此基本是基于自己的算法和丢包反馈来进行拥塞判断，本身存在一定的局限性。</p>\n<p>后来的一些路由器在处理数据包，可能可以感知到网络是否真正拥塞，当路由器感知到拥塞时，会通过设置TCP标志位的ECE给TCP，TCP发送端收到带有ECE的ack时会进入拥塞状态(状态机中的CWR)，同时发送一个携带标志位CWR的包给接收端，表示自己当前正在衰减拥塞窗口。</p>\n<h1 id=\"6-Selective-acknowledgements\"><a href=\"#6-Selective-acknowledgements\" class=\"headerlink\" title=\"6. Selective acknowledgements\"></a>6. Selective acknowledgements</h1><p>由于进入乱序或者快速重传后，在一个RTT之内只能处理一个异常包(不会发送新的包直到新的ack到来，但是当丢包是不连续的若干个，恢复完后仍然会进入对应状态，单独处理下一个乱序丢包，如发送端发送1-6，接收端先收到1，3，6，这时候发送先恢复包2，恢复完包2收到ack发现乱序，请求包4，发送端再恢复4，恢复后发现仍然乱序，请求包5，再次单独恢复包5)，因此在恢复阶段严重影响吞吐量。</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/tcp_recovery_multi_loss.png\" alt=\"Alt text\"></p>\n<p>SACK并没有打破原有的ack机制，只是在其ack机制上，在TCP option字段中附加了额外信息。<sup><a href=\"https://www.eecis.udel.edu/~amer/856/sack.04f.ppt\">4</a></sup></p>\n<p>例子如下图：<br><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/sack.png\" alt=\"Alt text\"></p>\n<ul>\n<li><p>Multiple packet losses from a window of data can have a catastrophic effect on TCP throughput.</p>\n</li>\n<li><p>SACK does not change the meaning of ACK field.</p>\n</li>\n</ul>\n<p>注: SACK附加在TCP option字段中，option字段最多只有40字节，因此SACK最多包含四个区间。</p>\n<ul>\n<li>A SACK option that specifies n blocks will have a length of 8*n+2 bytes, so the 40 bytes available for TCP options can specify a   maximum of 4 blocks.</li>\n</ul>\n<p>注2: SACK必须接收和发送端都支持才可以正常使用。</p>\n<h1 id=\"7-Duplicate-SACK\"><a href=\"#7-Duplicate-SACK\" class=\"headerlink\" title=\"7. Duplicate-SACK\"></a>7. Duplicate-SACK</h1><p>SACK在rfc 2018定义的时候，并没有声明其收到两个相同的包以后的处理。D-SACK会使接收端发送重复块的信息给发送端。</p>\n<p>简单流程如下：<br>当DSACK激活时，最后一个ACK中的SACK第一个区域为重复区域，不同于普通SACK，它是已经收到的区域的一个子区间，每个重复块只会上报一次。</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/dsack.png\" alt=\"Alt text\"></p>\n<h1 id=\"8-Forward-Acknowledgements\"><a href=\"#8-Forward-Acknowledgements\" class=\"headerlink\" title=\"8. Forward Acknowledgements\"></a>8. Forward Acknowledgements</h1><p>Forward Acknowledgement是基于SACK的相关的拥塞控制算法。</p>\n<p>当拥塞发生时，此时已经发生丢包，这时候会引入新的变量fackets_out来统计SACK中的数据量，并根据当前已经发送的数据量una和重传数据量retran来估算本条连接实际在网络中的包数量(总包数 - 已经ACK的数量 + 重传包)。并根据这个数值和拥塞窗口进行比较，如果当前网络中的包数量小于拥塞窗口，说明仍然可以往网络中发送部分数量的包。</p>\n<p>这种算法本质上是对网络中的包数量进行更精确的估计，结合DSACK，可以更精准的进行判断，可以在恢复阶段依旧保持一定的速率，在处理乱序包的时候可以比传统TCP更加激进。</p>\n<h1 id=\"9-FRTO\"><a href=\"#9-FRTO\" class=\"headerlink\" title=\"9. FRTO\"></a>9. FRTO</h1><p>当网络链路存在一些突发的特殊场景时，可能会触发超时定时器，由于TCP对于丢包的处理异常严格，可能会造成链路质量下降。</p>\n<p>可能的一些场景：</p>\n<ul>\n<li>对于移动信号的跨域处理，可能会造成突发的延迟。</li>\n<li>对于低带宽链路，偶发的竞争可能也会造成整个RTT的增加。</li>\n<li><p>稳定的链路上可能也有一些原因导致某些包及其重传老是失败。</p>\n</li>\n<li><p>First, some mobile networking technologies involve sudden delay spikes on transmission because of actions taken during a hand-off.  </p>\n</li>\n<li>Second, given a low-bandwidth link or some other change in available bandwidth, arrival of competing traffic (possibly with higher priority) can cause a sudden increase of round-trip time. This may trigger a spurious retransmission timeout. </li>\n<li>A persistently reliable link layer can also cause a sudden delay when a data frame and several retransmissions of it are lost for some reason.</li>\n</ul>\n<p>可能造成的一些影响：</p>\n<ul>\n<li>虚假超时后的慢启动可能会导致向已经产生拥塞的网络中注入更多的数据包，会严重影响实际网络的拥塞状态。</li>\n<li><p>当虚假超时触发后，可能造成虚假重传，当过多虚假重传发生后，对应的ack回来时可能会触发虚假的快速恢复，如下图，第二次虚假的快速重传是由于第一次虚假RTO超时导致重传发送了重复包导致。</p>\n</li>\n<li><p>However, if the RTO occurs spuriously and there still are segments outstanding in the network, a false slow start is harmful for the potentially congested network as it injects extra segments to the network at increasing rate.</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/frto.png\" alt=\"Alt text\"></p>\n<p>FRTO会在RTO超时后，不会类似传统TCP的超时机制，会额外根据后续两个ACK与当前未确认的最小包进行比较，根据这个结果判断当前RTO是否在安全范围内。<br>如果收到的是未确认的包之后的包，则可能是因为网络原因导致的延迟，可以进入恢复状态。<br>如果收到的是重复的ack，则认为这个包确实已经丢失，进入丢包状态。</p>\n<h1 id=\"10-概览图\"><a href=\"#10-概览图\" class=\"headerlink\" title=\"10. 概览图\"></a>10. 概览图</h1><p>简单用图画出之间衍生的关系。  </p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/TCP简介/概览.png\" alt=\"Alt text\"></p>\n"},{"title":"webrtc中rtcp码率控制分析","date":"2017-05-09T03:22:45.000Z","_content":"\n# 0. 参考文档\n[1] [google congestion control](http://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf)\n\n# 1. 简介\n\nwebrtc的带宽估计分为两部分，一部分为发送端根据rtcp反馈信息进行反馈，另一部分为接收端根据收到的rtp数据进行相应的码率估计[[1]]。\n本文先分析发送端根据rtcp反馈信息进行码率调整的部分代码。\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/google_congestion_control_architecture.png)\n\n具体计算公式:\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback.png)\n\n# 2. 代码结构\n## 2.1 类关系\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback_class.png)\n\nrtp\\_stream\\_receiver中有一个继承自抽象类RtpRtcp的ModuleRtpRtcpImpl，ModuleRtpRtcpImpl中有一个rtcp\\_receiver。当有RTCP包到来时，逐层处理至rtcp\\_receiver，当包是rtcp receiver report包，则会将包解析，然后在ModuleRtpRtcpImpl中再次调用rtcp\\_receiver中的TriggerCallbacksFromRTCPPacket函数，触发对应rtcp的一些事件，反馈触发的主要是\\_cbRtcpBandwidthObserver的观察者(RtcpBandwidthObserverImpl)，这个观察者收到对应的report block之后会计算成带宽估计所需要的参数，并调用属主bitratecontrolImpl类对带宽进行估计，这里会调用SendSideBandwidthEstimation中的UpdateReceiverBlock进行实际的带宽评估。\n\n## 2.2 调用关系图\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback_flow.png)\n\n# 3. 代码分析\n## 3.1 HandleReportBlock\n这个函数中最主要的部分就是RTT的计算，webrtc中对于RTT平滑的因子是一个线性增长的因子。\n\n```cpp\n/* 这个函数根据对应的report block生成了一个新的RTCPReportBlockInformation结构体，\n * 并计算出对应的RTT，多report block在调用点处执行循环。  */\nvoid RTCPReceiver::HandleReportBlock(\n    const RTCPUtility::RTCPPacket& rtcpPacket,\n    RTCPPacketInformation& rtcpPacketInformation,\n    uint32_t remoteSSRC)\n    EXCLUSIVE_LOCKS_REQUIRED(_criticalSectionRTCPReceiver) {\n  // This will be called once per report block in the RTCP packet.\n  // We filter out all report blocks that are not for us.\n  // Each packet has max 31 RR blocks.\n  //\n  // We can calc RTT if we send a send report and get a report block back.\n\n  // |rtcpPacket.ReportBlockItem.SSRC| is the SSRC identifier of the source to\n  // which the information in this reception report block pertains.\n\n  // Filter out all report blocks that are not for us.\n  if (registered_ssrcs_.find(rtcpPacket.ReportBlockItem.SSRC) ==\n      registered_ssrcs_.end()) {\n    // This block is not for us ignore it.\n    return;\n  }\n\n  RTCPReportBlockInformation* reportBlock =\n      CreateOrGetReportBlockInformation(remoteSSRC,\n                                        rtcpPacket.ReportBlockItem.SSRC);\n  if (reportBlock == NULL) {\n    LOG(LS_WARNING) << \"Failed to CreateReportBlockInformation(\"\n                    << remoteSSRC << \")\";\n    return;\n  }\n\n  // 用于RTCP超时的计算。\n  _lastReceivedRrMs = _clock->TimeInMilliseconds();\n  // 其他字段的拷贝。\n  const RTCPPacketReportBlockItem& rb = rtcpPacket.ReportBlockItem;\n  reportBlock->remoteReceiveBlock.remoteSSRC = remoteSSRC;\n  reportBlock->remoteReceiveBlock.sourceSSRC = rb.SSRC;\n  reportBlock->remoteReceiveBlock.fractionLost = rb.FractionLost;\n  reportBlock->remoteReceiveBlock.cumulativeLost =\n      rb.CumulativeNumOfPacketsLost;\n  if (rb.ExtendedHighestSequenceNumber >\n      reportBlock->remoteReceiveBlock.extendedHighSeqNum) {\n    // We have successfully delivered new RTP packets to the remote side after\n    // the last RR was sent from the remote side.\n    _lastIncreasedSequenceNumberMs = _lastReceivedRrMs;\n  }\n  reportBlock->remoteReceiveBlock.extendedHighSeqNum =\n      rb.ExtendedHighestSequenceNumber;\n  reportBlock->remoteReceiveBlock.jitter = rb.Jitter;\n  reportBlock->remoteReceiveBlock.delaySinceLastSR = rb.DelayLastSR;\n  reportBlock->remoteReceiveBlock.lastSR = rb.LastSR;\n\n  if (rtcpPacket.ReportBlockItem.Jitter > reportBlock->remoteMaxJitter) {\n    reportBlock->remoteMaxJitter = rtcpPacket.ReportBlockItem.Jitter;\n  }\n\n  int64_t rtt = 0;\n  uint32_t send_time = rtcpPacket.ReportBlockItem.LastSR;\n  // RFC3550, section 6.4.1, LSR field discription states:\n  // If no SR has been received yet, the field is set to zero.\n  // Receiver rtp_rtcp module is not expected to calculate rtt using\n  // Sender Reports even if it accidentally can.\n  if (!receiver_only_ && send_time != 0) {\n\t// 当RR在SR之前发送，send_time为0.\n\t// delay计算:\n\t// Send SR                                                       Receive RR\n\t//  |                          delay in RR                           |\n \t//  |                        |<----------->|                         |\n\t//  |<---------------------->|             |<----------------------->|\n\t//\n\t// RTT = total_time - delay_in_RR\n\t//     = receiver_rr_time - send_sr_time - delay_in_RR\n\t// 即使中间几个SR丢包，但是如果RTT本身是平滑的，那么RTT不会受到这几个丢包的影响\n\t// 因为SR->RR之间的delay可以精确计算。\n    uint32_t delay = rtcpPacket.ReportBlockItem.DelayLastSR;\n    // Local NTP time.\n    uint32_t receive_time = CompactNtp(NtpTime(*_clock));\n\n    // RTT in 1/(2^16) seconds.\n    uint32_t rtt_ntp = receive_time - delay - send_time;\n    // Convert to 1/1000 seconds (milliseconds).\n    rtt = CompactNtpRttToMs(rtt_ntp);\n    if (rtt > reportBlock->maxRTT) {\n      // Store max RTT.\n      reportBlock->maxRTT = rtt;\n    }\n    if (reportBlock->minRTT == 0) {\n      // First RTT.\n      reportBlock->minRTT = rtt;\n    } else if (rtt < reportBlock->minRTT) {\n      // Store min RTT.\n      reportBlock->minRTT = rtt;\n    }\n    // Store last RTT.\n    reportBlock->RTT = rtt;\n\n    // store average RTT\n\t// RTT的平滑计算。\n\t// 如果这个块是在CreateOrGetReportBlockInformation新生成的，\n\t// 则权重会从0开始随着受到的report逐渐递增。\n\t// srtt(i) = i/(i+1)*srtt(i-1) + 1/(i+1)*rtt + 0.5\n    if (reportBlock->numAverageCalcs != 0) {\n      float ac = static_cast<float>(reportBlock->numAverageCalcs);\n      float newAverage =\n          ((ac / (ac + 1)) * reportBlock->avgRTT) + ((1 / (ac + 1)) * rtt);\n      reportBlock->avgRTT = static_cast<int64_t>(newAverage + 0.5f);\n    } else {\n      // First RTT.\n      reportBlock->avgRTT = rtt;\n    }\n    reportBlock->numAverageCalcs++;\n  }\n\n  TRACE_COUNTER_ID1(TRACE_DISABLED_BY_DEFAULT(\"webrtc_rtp\"), \"RR_RTT\", rb.SSRC,\n                    rtt);\n\n  // 添加回rtcpPacketInformation，在ModuleRtpRtcpImpl中会使用这个进行事件回调。\n  rtcpPacketInformation.AddReportInfo(*reportBlock);\n}\n```\n\n## 3.2 UpdateMinHistory\n\n这个函数主要用于更新变量min\\_bitrate\\_history\\_，这个变量将会作用于上升区间，用来作为基数，这里简单描述下。\n\n```cpp\n// Updates history of min bitrates.\n// After this method returns min_bitrate_history_.front().second contains the\n// min bitrate used during last kBweIncreaseIntervalMs.\n// 主要结合这个函数解释下变量min_bitrate_history_\n// 这个变量的两个维度，front记录的是离当前最远的时间，\n// 每个速率都是按照时间先后顺序逐渐push到尾部。\n// 因此更新的时候，需要先将超时的元素从列表头剔除。\n// 后一个维度是最小速率值，\n// 在相同的时间区间内，保留最小的速率值。\n// |-------Interval 1---------|----------Interval 2------|\n// |                          |                          |\n// |--t1 < t2 < t3 < t4 < t5--|--t1 < t2 < t3 < t4 < t5--|\n// 这样的操作较为简单，不用在每次插入元素时去判断对应的时间区域，再找到对应时间区间的最小值，用部分冗余的内存换取操作的快捷。\nvoid SendSideBandwidthEstimation::UpdateMinHistory(int64_t now_ms) {\n  // Remove old data points from history.\n  // Since history precision is in ms, add one so it is able to increase\n  // bitrate if it is off by as little as 0.5ms.\n  while (!min_bitrate_history_.empty() &&\n         now_ms - min_bitrate_history_.front().first + 1 >\n             kBweIncreaseIntervalMs) {\n    min_bitrate_history_.pop_front();\n  }\n\n  // Typical minimum sliding-window algorithm: Pop values higher than current\n  // bitrate before pushing it.\n  while (!min_bitrate_history_.empty() &&\n         bitrate_ <= min_bitrate_history_.back().second) {\n    min_bitrate_history_.pop_back();\n  }\n\n  min_bitrate_history_.push_back(std::make_pair(now_ms, bitrate_));\n}\n```\n\n## 3.3 UpdateEstimate\n函数UpdateReceiverBlock会根据当前的report block对当前带宽估计的一些变量进行相应的赋值，此外，只有当传输包的数量达到一定数量才会再次触发带宽估计的调整。函数UpdateEstimate是主要用于带宽估计的函数。\n\n```cpp\nvoid SendSideBandwidthEstimation::UpdateEstimate(int64_t now_ms) {\n  // We trust the REMB and/or delay-based estimate during the first 2 seconds if\n  // we haven't had any packet loss reported, to allow startup bitrate probing.\n  if (last_fraction_loss_ == 0 && IsInStartPhase(now_ms)) {\n    uint32_t prev_bitrate = bitrate_;\n\t// bwe_incoming_是remb更新的值，如果当前无丢包且在启动阶段，直接使用remb的值。\n    if (bwe_incoming_ > bitrate_)\n      bitrate_ = CapBitrateToThresholds(now_ms, bwe_incoming_);\n      ...\n    }\n  }\n  UpdateMinHistory(now_ms);\n  // Only start updating bitrate when receiving receiver blocks.\n  // TODO(pbos): Handle the case when no receiver report is received for a very\n  // long time.\n  if (time_last_receiver_block_ms_ != -1) {\n    if (last_fraction_loss_ <= 5) {\n      // Loss < 2%: Increase rate by 8% of the min bitrate in the last\n      // kBweIncreaseIntervalMs.\n      // Note that by remembering the bitrate over the last second one can\n      // rampup up one second faster than if only allowed to start ramping\n      // at 8% per second rate now. E.g.:\n      //   If sending a constant 100kbps it can rampup immediatly to 108kbps\n      //   whenever a receiver report is received with lower packet loss.\n      //   If instead one would do: bitrate_ *= 1.08^(delta time), it would\n      //   take over one second since the lower packet loss to achieve 108kbps.\n        \n        //TODO:tjl\n\t  // 这里与公式有一定不同：\n\t  // 1. 系数不同，且附带一定的修正值(向上取整加1kbps)\n\t  // 2. 取的是上一个时间间隔之内最小值，比较平滑。\n      bitrate_ = static_cast<uint32_t>(\n          min_bitrate_history_.front().second * 1.08 + 0.5);\n\n      // Add 1 kbps extra, just to make sure that we do not get stuck\n      // (gives a little extra increase at low rates, negligible at higher\n      // rates).\n      bitrate_ += 1000;\n\n      event_log_->LogBwePacketLossEvent(\n          bitrate_, last_fraction_loss_,\n          expected_packets_since_last_loss_update_);\n    } else if (last_fraction_loss_ <= 26) {\n      // Loss between 2% - 10%: Do nothing.\n    } else {\n      // Loss > 10%: Limit the rate decreases to once a kBweDecreaseIntervalMs +\n      // rtt.\n      if (!has_decreased_since_last_fraction_loss_ &&\n          (now_ms - time_last_decrease_ms_) >=\n              (kBweDecreaseIntervalMs + last_round_trip_time_ms_)) {\n        time_last_decrease_ms_ = now_ms;\n\n        // Reduce rate:\n        //   newRate = rate * (1 - 0.5*lossRate);\n        //   where packetLoss = 256*lossRate;\n          \n          //TODO:tjl\n\t\t// 当从未开始降低窗口值，且距离上一次衰减的时间差大于衰减周期加上rtt。\n\t\t// 其实当前貌似只有这个case下会对这两个变量赋值。\n\t\t// 这里的last_fraction_loss_是一次统计间隔(一定包数)之间的总丢包率。\n\t\t// 丢包率的单位是1/256，因此这里是(1 - 丢包率/2) * 当前速率\n\t\t// 与公式相同。\n        bitrate_ = static_cast<uint32_t>(\n            (bitrate_ * static_cast<double>(512 - last_fraction_loss_)) /\n            512.0);\n        has_decreased_since_last_fraction_loss_ = true;\n      }\n      event_log_->LogBwePacketLossEvent(\n          bitrate_, last_fraction_loss_,\n          expected_packets_since_last_loss_update_);\n    }\n  }\n  // 在有效范围内修正。\n  bitrate_ = CapBitrateToThresholds(now_ms, bitrate_);\n}\n```\n\n[1]: [http://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf]\n\n","source":"_posts/webrtc中rtcp码率控制分析.md","raw":"---\ntitle: webrtc中rtcp码率控制分析\ndate: 2017-05-09 11:22:45\ntags: [webrt]\n---\n\n# 0. 参考文档\n[1] [google congestion control](http://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf)\n\n# 1. 简介\n\nwebrtc的带宽估计分为两部分，一部分为发送端根据rtcp反馈信息进行反馈，另一部分为接收端根据收到的rtp数据进行相应的码率估计[[1]]。\n本文先分析发送端根据rtcp反馈信息进行码率调整的部分代码。\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/google_congestion_control_architecture.png)\n\n具体计算公式:\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback.png)\n\n# 2. 代码结构\n## 2.1 类关系\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback_class.png)\n\nrtp\\_stream\\_receiver中有一个继承自抽象类RtpRtcp的ModuleRtpRtcpImpl，ModuleRtpRtcpImpl中有一个rtcp\\_receiver。当有RTCP包到来时，逐层处理至rtcp\\_receiver，当包是rtcp receiver report包，则会将包解析，然后在ModuleRtpRtcpImpl中再次调用rtcp\\_receiver中的TriggerCallbacksFromRTCPPacket函数，触发对应rtcp的一些事件，反馈触发的主要是\\_cbRtcpBandwidthObserver的观察者(RtcpBandwidthObserverImpl)，这个观察者收到对应的report block之后会计算成带宽估计所需要的参数，并调用属主bitratecontrolImpl类对带宽进行估计，这里会调用SendSideBandwidthEstimation中的UpdateReceiverBlock进行实际的带宽评估。\n\n## 2.2 调用关系图\n\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback_flow.png)\n\n# 3. 代码分析\n## 3.1 HandleReportBlock\n这个函数中最主要的部分就是RTT的计算，webrtc中对于RTT平滑的因子是一个线性增长的因子。\n\n```cpp\n/* 这个函数根据对应的report block生成了一个新的RTCPReportBlockInformation结构体，\n * 并计算出对应的RTT，多report block在调用点处执行循环。  */\nvoid RTCPReceiver::HandleReportBlock(\n    const RTCPUtility::RTCPPacket& rtcpPacket,\n    RTCPPacketInformation& rtcpPacketInformation,\n    uint32_t remoteSSRC)\n    EXCLUSIVE_LOCKS_REQUIRED(_criticalSectionRTCPReceiver) {\n  // This will be called once per report block in the RTCP packet.\n  // We filter out all report blocks that are not for us.\n  // Each packet has max 31 RR blocks.\n  //\n  // We can calc RTT if we send a send report and get a report block back.\n\n  // |rtcpPacket.ReportBlockItem.SSRC| is the SSRC identifier of the source to\n  // which the information in this reception report block pertains.\n\n  // Filter out all report blocks that are not for us.\n  if (registered_ssrcs_.find(rtcpPacket.ReportBlockItem.SSRC) ==\n      registered_ssrcs_.end()) {\n    // This block is not for us ignore it.\n    return;\n  }\n\n  RTCPReportBlockInformation* reportBlock =\n      CreateOrGetReportBlockInformation(remoteSSRC,\n                                        rtcpPacket.ReportBlockItem.SSRC);\n  if (reportBlock == NULL) {\n    LOG(LS_WARNING) << \"Failed to CreateReportBlockInformation(\"\n                    << remoteSSRC << \")\";\n    return;\n  }\n\n  // 用于RTCP超时的计算。\n  _lastReceivedRrMs = _clock->TimeInMilliseconds();\n  // 其他字段的拷贝。\n  const RTCPPacketReportBlockItem& rb = rtcpPacket.ReportBlockItem;\n  reportBlock->remoteReceiveBlock.remoteSSRC = remoteSSRC;\n  reportBlock->remoteReceiveBlock.sourceSSRC = rb.SSRC;\n  reportBlock->remoteReceiveBlock.fractionLost = rb.FractionLost;\n  reportBlock->remoteReceiveBlock.cumulativeLost =\n      rb.CumulativeNumOfPacketsLost;\n  if (rb.ExtendedHighestSequenceNumber >\n      reportBlock->remoteReceiveBlock.extendedHighSeqNum) {\n    // We have successfully delivered new RTP packets to the remote side after\n    // the last RR was sent from the remote side.\n    _lastIncreasedSequenceNumberMs = _lastReceivedRrMs;\n  }\n  reportBlock->remoteReceiveBlock.extendedHighSeqNum =\n      rb.ExtendedHighestSequenceNumber;\n  reportBlock->remoteReceiveBlock.jitter = rb.Jitter;\n  reportBlock->remoteReceiveBlock.delaySinceLastSR = rb.DelayLastSR;\n  reportBlock->remoteReceiveBlock.lastSR = rb.LastSR;\n\n  if (rtcpPacket.ReportBlockItem.Jitter > reportBlock->remoteMaxJitter) {\n    reportBlock->remoteMaxJitter = rtcpPacket.ReportBlockItem.Jitter;\n  }\n\n  int64_t rtt = 0;\n  uint32_t send_time = rtcpPacket.ReportBlockItem.LastSR;\n  // RFC3550, section 6.4.1, LSR field discription states:\n  // If no SR has been received yet, the field is set to zero.\n  // Receiver rtp_rtcp module is not expected to calculate rtt using\n  // Sender Reports even if it accidentally can.\n  if (!receiver_only_ && send_time != 0) {\n\t// 当RR在SR之前发送，send_time为0.\n\t// delay计算:\n\t// Send SR                                                       Receive RR\n\t//  |                          delay in RR                           |\n \t//  |                        |<----------->|                         |\n\t//  |<---------------------->|             |<----------------------->|\n\t//\n\t// RTT = total_time - delay_in_RR\n\t//     = receiver_rr_time - send_sr_time - delay_in_RR\n\t// 即使中间几个SR丢包，但是如果RTT本身是平滑的，那么RTT不会受到这几个丢包的影响\n\t// 因为SR->RR之间的delay可以精确计算。\n    uint32_t delay = rtcpPacket.ReportBlockItem.DelayLastSR;\n    // Local NTP time.\n    uint32_t receive_time = CompactNtp(NtpTime(*_clock));\n\n    // RTT in 1/(2^16) seconds.\n    uint32_t rtt_ntp = receive_time - delay - send_time;\n    // Convert to 1/1000 seconds (milliseconds).\n    rtt = CompactNtpRttToMs(rtt_ntp);\n    if (rtt > reportBlock->maxRTT) {\n      // Store max RTT.\n      reportBlock->maxRTT = rtt;\n    }\n    if (reportBlock->minRTT == 0) {\n      // First RTT.\n      reportBlock->minRTT = rtt;\n    } else if (rtt < reportBlock->minRTT) {\n      // Store min RTT.\n      reportBlock->minRTT = rtt;\n    }\n    // Store last RTT.\n    reportBlock->RTT = rtt;\n\n    // store average RTT\n\t// RTT的平滑计算。\n\t// 如果这个块是在CreateOrGetReportBlockInformation新生成的，\n\t// 则权重会从0开始随着受到的report逐渐递增。\n\t// srtt(i) = i/(i+1)*srtt(i-1) + 1/(i+1)*rtt + 0.5\n    if (reportBlock->numAverageCalcs != 0) {\n      float ac = static_cast<float>(reportBlock->numAverageCalcs);\n      float newAverage =\n          ((ac / (ac + 1)) * reportBlock->avgRTT) + ((1 / (ac + 1)) * rtt);\n      reportBlock->avgRTT = static_cast<int64_t>(newAverage + 0.5f);\n    } else {\n      // First RTT.\n      reportBlock->avgRTT = rtt;\n    }\n    reportBlock->numAverageCalcs++;\n  }\n\n  TRACE_COUNTER_ID1(TRACE_DISABLED_BY_DEFAULT(\"webrtc_rtp\"), \"RR_RTT\", rb.SSRC,\n                    rtt);\n\n  // 添加回rtcpPacketInformation，在ModuleRtpRtcpImpl中会使用这个进行事件回调。\n  rtcpPacketInformation.AddReportInfo(*reportBlock);\n}\n```\n\n## 3.2 UpdateMinHistory\n\n这个函数主要用于更新变量min\\_bitrate\\_history\\_，这个变量将会作用于上升区间，用来作为基数，这里简单描述下。\n\n```cpp\n// Updates history of min bitrates.\n// After this method returns min_bitrate_history_.front().second contains the\n// min bitrate used during last kBweIncreaseIntervalMs.\n// 主要结合这个函数解释下变量min_bitrate_history_\n// 这个变量的两个维度，front记录的是离当前最远的时间，\n// 每个速率都是按照时间先后顺序逐渐push到尾部。\n// 因此更新的时候，需要先将超时的元素从列表头剔除。\n// 后一个维度是最小速率值，\n// 在相同的时间区间内，保留最小的速率值。\n// |-------Interval 1---------|----------Interval 2------|\n// |                          |                          |\n// |--t1 < t2 < t3 < t4 < t5--|--t1 < t2 < t3 < t4 < t5--|\n// 这样的操作较为简单，不用在每次插入元素时去判断对应的时间区域，再找到对应时间区间的最小值，用部分冗余的内存换取操作的快捷。\nvoid SendSideBandwidthEstimation::UpdateMinHistory(int64_t now_ms) {\n  // Remove old data points from history.\n  // Since history precision is in ms, add one so it is able to increase\n  // bitrate if it is off by as little as 0.5ms.\n  while (!min_bitrate_history_.empty() &&\n         now_ms - min_bitrate_history_.front().first + 1 >\n             kBweIncreaseIntervalMs) {\n    min_bitrate_history_.pop_front();\n  }\n\n  // Typical minimum sliding-window algorithm: Pop values higher than current\n  // bitrate before pushing it.\n  while (!min_bitrate_history_.empty() &&\n         bitrate_ <= min_bitrate_history_.back().second) {\n    min_bitrate_history_.pop_back();\n  }\n\n  min_bitrate_history_.push_back(std::make_pair(now_ms, bitrate_));\n}\n```\n\n## 3.3 UpdateEstimate\n函数UpdateReceiverBlock会根据当前的report block对当前带宽估计的一些变量进行相应的赋值，此外，只有当传输包的数量达到一定数量才会再次触发带宽估计的调整。函数UpdateEstimate是主要用于带宽估计的函数。\n\n```cpp\nvoid SendSideBandwidthEstimation::UpdateEstimate(int64_t now_ms) {\n  // We trust the REMB and/or delay-based estimate during the first 2 seconds if\n  // we haven't had any packet loss reported, to allow startup bitrate probing.\n  if (last_fraction_loss_ == 0 && IsInStartPhase(now_ms)) {\n    uint32_t prev_bitrate = bitrate_;\n\t// bwe_incoming_是remb更新的值，如果当前无丢包且在启动阶段，直接使用remb的值。\n    if (bwe_incoming_ > bitrate_)\n      bitrate_ = CapBitrateToThresholds(now_ms, bwe_incoming_);\n      ...\n    }\n  }\n  UpdateMinHistory(now_ms);\n  // Only start updating bitrate when receiving receiver blocks.\n  // TODO(pbos): Handle the case when no receiver report is received for a very\n  // long time.\n  if (time_last_receiver_block_ms_ != -1) {\n    if (last_fraction_loss_ <= 5) {\n      // Loss < 2%: Increase rate by 8% of the min bitrate in the last\n      // kBweIncreaseIntervalMs.\n      // Note that by remembering the bitrate over the last second one can\n      // rampup up one second faster than if only allowed to start ramping\n      // at 8% per second rate now. E.g.:\n      //   If sending a constant 100kbps it can rampup immediatly to 108kbps\n      //   whenever a receiver report is received with lower packet loss.\n      //   If instead one would do: bitrate_ *= 1.08^(delta time), it would\n      //   take over one second since the lower packet loss to achieve 108kbps.\n        \n        //TODO:tjl\n\t  // 这里与公式有一定不同：\n\t  // 1. 系数不同，且附带一定的修正值(向上取整加1kbps)\n\t  // 2. 取的是上一个时间间隔之内最小值，比较平滑。\n      bitrate_ = static_cast<uint32_t>(\n          min_bitrate_history_.front().second * 1.08 + 0.5);\n\n      // Add 1 kbps extra, just to make sure that we do not get stuck\n      // (gives a little extra increase at low rates, negligible at higher\n      // rates).\n      bitrate_ += 1000;\n\n      event_log_->LogBwePacketLossEvent(\n          bitrate_, last_fraction_loss_,\n          expected_packets_since_last_loss_update_);\n    } else if (last_fraction_loss_ <= 26) {\n      // Loss between 2% - 10%: Do nothing.\n    } else {\n      // Loss > 10%: Limit the rate decreases to once a kBweDecreaseIntervalMs +\n      // rtt.\n      if (!has_decreased_since_last_fraction_loss_ &&\n          (now_ms - time_last_decrease_ms_) >=\n              (kBweDecreaseIntervalMs + last_round_trip_time_ms_)) {\n        time_last_decrease_ms_ = now_ms;\n\n        // Reduce rate:\n        //   newRate = rate * (1 - 0.5*lossRate);\n        //   where packetLoss = 256*lossRate;\n          \n          //TODO:tjl\n\t\t// 当从未开始降低窗口值，且距离上一次衰减的时间差大于衰减周期加上rtt。\n\t\t// 其实当前貌似只有这个case下会对这两个变量赋值。\n\t\t// 这里的last_fraction_loss_是一次统计间隔(一定包数)之间的总丢包率。\n\t\t// 丢包率的单位是1/256，因此这里是(1 - 丢包率/2) * 当前速率\n\t\t// 与公式相同。\n        bitrate_ = static_cast<uint32_t>(\n            (bitrate_ * static_cast<double>(512 - last_fraction_loss_)) /\n            512.0);\n        has_decreased_since_last_fraction_loss_ = true;\n      }\n      event_log_->LogBwePacketLossEvent(\n          bitrate_, last_fraction_loss_,\n          expected_packets_since_last_loss_update_);\n    }\n  }\n  // 在有效范围内修正。\n  bitrate_ = CapBitrateToThresholds(now_ms, bitrate_);\n}\n```\n\n[1]: [http://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf]\n\n","slug":"webrtc中rtcp码率控制分析","published":1,"updated":"2017-05-09T03:27:03.000Z","_id":"cj2gzs4jv0007r8c3wxppvvaw","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"0-参考文档\"><a href=\"#0-参考文档\" class=\"headerlink\" title=\"0. 参考文档\"></a>0. 参考文档</h1><p>[1] <a href=\"http://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf\" target=\"_blank\" rel=\"external\">google congestion control</a></p>\n<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>webrtc的带宽估计分为两部分，一部分为发送端根据rtcp反馈信息进行反馈，另一部分为接收端根据收到的rtp数据进行相应的码率估计[<a href=\"[http://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf]\">1</a>]。<br>本文先分析发送端根据rtcp反馈信息进行码率调整的部分代码。</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/google_congestion_control_architecture.png\" alt=\"\"></p>\n<p>具体计算公式:<br><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback.png\" alt=\"\"></p>\n<h1 id=\"2-代码结构\"><a href=\"#2-代码结构\" class=\"headerlink\" title=\"2. 代码结构\"></a>2. 代码结构</h1><h2 id=\"2-1-类关系\"><a href=\"#2-1-类关系\" class=\"headerlink\" title=\"2.1 类关系\"></a>2.1 类关系</h2><p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback_class.png\" alt=\"\"></p>\n<p>rtp_stream_receiver中有一个继承自抽象类RtpRtcp的ModuleRtpRtcpImpl，ModuleRtpRtcpImpl中有一个rtcp_receiver。当有RTCP包到来时，逐层处理至rtcp_receiver，当包是rtcp receiver report包，则会将包解析，然后在ModuleRtpRtcpImpl中再次调用rtcp_receiver中的TriggerCallbacksFromRTCPPacket函数，触发对应rtcp的一些事件，反馈触发的主要是_cbRtcpBandwidthObserver的观察者(RtcpBandwidthObserverImpl)，这个观察者收到对应的report block之后会计算成带宽估计所需要的参数，并调用属主bitratecontrolImpl类对带宽进行估计，这里会调用SendSideBandwidthEstimation中的UpdateReceiverBlock进行实际的带宽评估。</p>\n<h2 id=\"2-2-调用关系图\"><a href=\"#2-2-调用关系图\" class=\"headerlink\" title=\"2.2 调用关系图\"></a>2.2 调用关系图</h2><p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback_flow.png\" alt=\"\"></p>\n<h1 id=\"3-代码分析\"><a href=\"#3-代码分析\" class=\"headerlink\" title=\"3. 代码分析\"></a>3. 代码分析</h1><h2 id=\"3-1-HandleReportBlock\"><a href=\"#3-1-HandleReportBlock\" class=\"headerlink\" title=\"3.1 HandleReportBlock\"></a>3.1 HandleReportBlock</h2><p>这个函数中最主要的部分就是RTT的计算，webrtc中对于RTT平滑的因子是一个线性增长的因子。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 这个函数根据对应的report block生成了一个新的RTCPReportBlockInformation结构体，</span></div><div class=\"line\"> * 并计算出对应的RTT，多report block在调用点处执行循环。  */</div><div class=\"line\"><span class=\"keyword\">void</span> RTCPReceiver::HandleReportBlock(</div><div class=\"line\">    <span class=\"keyword\">const</span> RTCPUtility::RTCPPacket&amp; rtcpPacket,</div><div class=\"line\">    RTCPPacketInformation&amp; rtcpPacketInformation,</div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> remoteSSRC)</div><div class=\"line\">    EXCLUSIVE_LOCKS_REQUIRED(_criticalSectionRTCPReceiver) &#123;</div><div class=\"line\">  <span class=\"comment\">// This will be called once per report block in the RTCP packet.</span></div><div class=\"line\">  <span class=\"comment\">// We filter out all report blocks that are not for us.</span></div><div class=\"line\">  <span class=\"comment\">// Each packet has max 31 RR blocks.</span></div><div class=\"line\">  <span class=\"comment\">//</span></div><div class=\"line\">  <span class=\"comment\">// We can calc RTT if we send a send report and get a report block back.</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// |rtcpPacket.ReportBlockItem.SSRC| is the SSRC identifier of the source to</span></div><div class=\"line\">  <span class=\"comment\">// which the information in this reception report block pertains.</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Filter out all report blocks that are not for us.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (registered_ssrcs_.find(rtcpPacket.ReportBlockItem.SSRC) ==</div><div class=\"line\">      registered_ssrcs_.end()) &#123;</div><div class=\"line\">    <span class=\"comment\">// This block is not for us ignore it.</span></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  RTCPReportBlockInformation* reportBlock =</div><div class=\"line\">      CreateOrGetReportBlockInformation(remoteSSRC,</div><div class=\"line\">                                        rtcpPacket.ReportBlockItem.SSRC);</div><div class=\"line\">  <span class=\"keyword\">if</span> (reportBlock == <span class=\"literal\">NULL</span>) &#123;</div><div class=\"line\">    LOG(LS_WARNING) &lt;&lt; <span class=\"string\">\"Failed to CreateReportBlockInformation(\"</span></div><div class=\"line\">                    &lt;&lt; remoteSSRC &lt;&lt; <span class=\"string\">\")\"</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 用于RTCP超时的计算。</span></div><div class=\"line\">  _lastReceivedRrMs = _clock-&gt;TimeInMilliseconds();</div><div class=\"line\">  <span class=\"comment\">// 其他字段的拷贝。</span></div><div class=\"line\">  <span class=\"keyword\">const</span> RTCPPacketReportBlockItem&amp; rb = rtcpPacket.ReportBlockItem;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.remoteSSRC = remoteSSRC;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.sourceSSRC = rb.SSRC;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.fractionLost = rb.FractionLost;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.cumulativeLost =</div><div class=\"line\">      rb.CumulativeNumOfPacketsLost;</div><div class=\"line\">  <span class=\"keyword\">if</span> (rb.ExtendedHighestSequenceNumber &gt;</div><div class=\"line\">      reportBlock-&gt;remoteReceiveBlock.extendedHighSeqNum) &#123;</div><div class=\"line\">    <span class=\"comment\">// We have successfully delivered new RTP packets to the remote side after</span></div><div class=\"line\">    <span class=\"comment\">// the last RR was sent from the remote side.</span></div><div class=\"line\">    _lastIncreasedSequenceNumberMs = _lastReceivedRrMs;</div><div class=\"line\">  &#125;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.extendedHighSeqNum =</div><div class=\"line\">      rb.ExtendedHighestSequenceNumber;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.jitter = rb.Jitter;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.delaySinceLastSR = rb.DelayLastSR;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.lastSR = rb.LastSR;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (rtcpPacket.ReportBlockItem.Jitter &gt; reportBlock-&gt;remoteMaxJitter) &#123;</div><div class=\"line\">    reportBlock-&gt;remoteMaxJitter = rtcpPacket.ReportBlockItem.Jitter;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">int64_t</span> rtt = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">uint32_t</span> send_time = rtcpPacket.ReportBlockItem.LastSR;</div><div class=\"line\">  <span class=\"comment\">// RFC3550, section 6.4.1, LSR field discription states:</span></div><div class=\"line\">  <span class=\"comment\">// If no SR has been received yet, the field is set to zero.</span></div><div class=\"line\">  <span class=\"comment\">// Receiver rtp_rtcp module is not expected to calculate rtt using</span></div><div class=\"line\">  <span class=\"comment\">// Sender Reports even if it accidentally can.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!receiver_only_ &amp;&amp; send_time != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t<span class=\"comment\">// 当RR在SR之前发送，send_time为0.</span></div><div class=\"line\">\t<span class=\"comment\">// delay计算:</span></div><div class=\"line\">\t<span class=\"comment\">// Send SR                                                       Receive RR</span></div><div class=\"line\">\t<span class=\"comment\">//  |                          delay in RR                           |</span></div><div class=\"line\"> \t<span class=\"comment\">//  |                        |&lt;-----------&gt;|                         |</span></div><div class=\"line\">\t<span class=\"comment\">//  |&lt;----------------------&gt;|             |&lt;-----------------------&gt;|</span></div><div class=\"line\">\t<span class=\"comment\">//</span></div><div class=\"line\">\t<span class=\"comment\">// RTT = total_time - delay_in_RR</span></div><div class=\"line\">\t<span class=\"comment\">//     = receiver_rr_time - send_sr_time - delay_in_RR</span></div><div class=\"line\">\t<span class=\"comment\">// 即使中间几个SR丢包，但是如果RTT本身是平滑的，那么RTT不会受到这几个丢包的影响</span></div><div class=\"line\">\t<span class=\"comment\">// 因为SR-&gt;RR之间的delay可以精确计算。</span></div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> delay = rtcpPacket.ReportBlockItem.DelayLastSR;</div><div class=\"line\">    <span class=\"comment\">// Local NTP time.</span></div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> receive_time = CompactNtp(NtpTime(*_clock));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// RTT in 1/(2^16) seconds.</span></div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> rtt_ntp = receive_time - delay - send_time;</div><div class=\"line\">    <span class=\"comment\">// Convert to 1/1000 seconds (milliseconds).</span></div><div class=\"line\">    rtt = CompactNtpRttToMs(rtt_ntp);</div><div class=\"line\">    <span class=\"keyword\">if</span> (rtt &gt; reportBlock-&gt;maxRTT) &#123;</div><div class=\"line\">      <span class=\"comment\">// Store max RTT.</span></div><div class=\"line\">      reportBlock-&gt;maxRTT = rtt;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (reportBlock-&gt;minRTT == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// First RTT.</span></div><div class=\"line\">      reportBlock-&gt;minRTT = rtt;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rtt &lt; reportBlock-&gt;minRTT) &#123;</div><div class=\"line\">      <span class=\"comment\">// Store min RTT.</span></div><div class=\"line\">      reportBlock-&gt;minRTT = rtt;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Store last RTT.</span></div><div class=\"line\">    reportBlock-&gt;RTT = rtt;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// store average RTT</span></div><div class=\"line\">\t<span class=\"comment\">// RTT的平滑计算。</span></div><div class=\"line\">\t<span class=\"comment\">// 如果这个块是在CreateOrGetReportBlockInformation新生成的，</span></div><div class=\"line\">\t<span class=\"comment\">// 则权重会从0开始随着受到的report逐渐递增。</span></div><div class=\"line\">\t<span class=\"comment\">// srtt(i) = i/(i+1)*srtt(i-1) + 1/(i+1)*rtt + 0.5</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (reportBlock-&gt;numAverageCalcs != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">float</span> ac = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">float</span>&gt;(reportBlock-&gt;numAverageCalcs);</div><div class=\"line\">      <span class=\"keyword\">float</span> newAverage =</div><div class=\"line\">          ((ac / (ac + <span class=\"number\">1</span>)) * reportBlock-&gt;avgRTT) + ((<span class=\"number\">1</span> / (ac + <span class=\"number\">1</span>)) * rtt);</div><div class=\"line\">      reportBlock-&gt;avgRTT = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int64_t</span>&gt;(newAverage + <span class=\"number\">0.5f</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// First RTT.</span></div><div class=\"line\">      reportBlock-&gt;avgRTT = rtt;</div><div class=\"line\">    &#125;</div><div class=\"line\">    reportBlock-&gt;numAverageCalcs++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  TRACE_COUNTER_ID1(TRACE_DISABLED_BY_DEFAULT(<span class=\"string\">\"webrtc_rtp\"</span>), <span class=\"string\">\"RR_RTT\"</span>, rb.SSRC,</div><div class=\"line\">                    rtt);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 添加回rtcpPacketInformation，在ModuleRtpRtcpImpl中会使用这个进行事件回调。</span></div><div class=\"line\">  rtcpPacketInformation.AddReportInfo(*reportBlock);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-UpdateMinHistory\"><a href=\"#3-2-UpdateMinHistory\" class=\"headerlink\" title=\"3.2 UpdateMinHistory\"></a>3.2 UpdateMinHistory</h2><p>这个函数主要用于更新变量min_bitrate_history_，这个变量将会作用于上升区间，用来作为基数，这里简单描述下。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Updates history of min bitrates.</span></div><div class=\"line\"><span class=\"comment\">// After this method returns min_bitrate_history_.front().second contains the</span></div><div class=\"line\"><span class=\"comment\">// min bitrate used during last kBweIncreaseIntervalMs.</span></div><div class=\"line\"><span class=\"comment\">// 主要结合这个函数解释下变量min_bitrate_history_</span></div><div class=\"line\"><span class=\"comment\">// 这个变量的两个维度，front记录的是离当前最远的时间，</span></div><div class=\"line\"><span class=\"comment\">// 每个速率都是按照时间先后顺序逐渐push到尾部。</span></div><div class=\"line\"><span class=\"comment\">// 因此更新的时候，需要先将超时的元素从列表头剔除。</span></div><div class=\"line\"><span class=\"comment\">// 后一个维度是最小速率值，</span></div><div class=\"line\"><span class=\"comment\">// 在相同的时间区间内，保留最小的速率值。</span></div><div class=\"line\"><span class=\"comment\">// |-------Interval 1---------|----------Interval 2------|</span></div><div class=\"line\"><span class=\"comment\">// |                          |                          |</span></div><div class=\"line\"><span class=\"comment\">// |--t1 &lt; t2 &lt; t3 &lt; t4 &lt; t5--|--t1 &lt; t2 &lt; t3 &lt; t4 &lt; t5--|</span></div><div class=\"line\"><span class=\"comment\">// 这样的操作较为简单，不用在每次插入元素时去判断对应的时间区域，再找到对应时间区间的最小值，用部分冗余的内存换取操作的快捷。</span></div><div class=\"line\"><span class=\"keyword\">void</span> SendSideBandwidthEstimation::UpdateMinHistory(<span class=\"keyword\">int64_t</span> now_ms) &#123;</div><div class=\"line\">  <span class=\"comment\">// Remove old data points from history.</span></div><div class=\"line\">  <span class=\"comment\">// Since history precision is in ms, add one so it is able to increase</span></div><div class=\"line\">  <span class=\"comment\">// bitrate if it is off by as little as 0.5ms.</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (!min_bitrate_history_.empty() &amp;&amp;</div><div class=\"line\">         now_ms - min_bitrate_history_.front().first + <span class=\"number\">1</span> &gt;</div><div class=\"line\">             kBweIncreaseIntervalMs) &#123;</div><div class=\"line\">    min_bitrate_history_.pop_front();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Typical minimum sliding-window algorithm: Pop values higher than current</span></div><div class=\"line\">  <span class=\"comment\">// bitrate before pushing it.</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (!min_bitrate_history_.empty() &amp;&amp;</div><div class=\"line\">         bitrate_ &lt;= min_bitrate_history_.back().second) &#123;</div><div class=\"line\">    min_bitrate_history_.pop_back();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  min_bitrate_history_.push_back(<span class=\"built_in\">std</span>::make_pair(now_ms, bitrate_));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-3-UpdateEstimate\"><a href=\"#3-3-UpdateEstimate\" class=\"headerlink\" title=\"3.3 UpdateEstimate\"></a>3.3 UpdateEstimate</h2><p>函数UpdateReceiverBlock会根据当前的report block对当前带宽估计的一些变量进行相应的赋值，此外，只有当传输包的数量达到一定数量才会再次触发带宽估计的调整。函数UpdateEstimate是主要用于带宽估计的函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> SendSideBandwidthEstimation::UpdateEstimate(<span class=\"keyword\">int64_t</span> now_ms) &#123;</div><div class=\"line\">  <span class=\"comment\">// We trust the REMB and/or delay-based estimate during the first 2 seconds if</span></div><div class=\"line\">  <span class=\"comment\">// we haven't had any packet loss reported, to allow startup bitrate probing.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (last_fraction_loss_ == <span class=\"number\">0</span> &amp;&amp; IsInStartPhase(now_ms)) &#123;</div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> prev_bitrate = bitrate_;</div><div class=\"line\">\t<span class=\"comment\">// bwe_incoming_是remb更新的值，如果当前无丢包且在启动阶段，直接使用remb的值。</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (bwe_incoming_ &gt; bitrate_)</div><div class=\"line\">      bitrate_ = CapBitrateToThresholds(now_ms, bwe_incoming_);</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  UpdateMinHistory(now_ms);</div><div class=\"line\">  <span class=\"comment\">// Only start updating bitrate when receiving receiver blocks.</span></div><div class=\"line\">  <span class=\"comment\">// TODO(pbos): Handle the case when no receiver report is received for a very</span></div><div class=\"line\">  <span class=\"comment\">// long time.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (time_last_receiver_block_ms_ != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (last_fraction_loss_ &lt;= <span class=\"number\">5</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// Loss &lt; 2%: Increase rate by 8% of the min bitrate in the last</span></div><div class=\"line\">      <span class=\"comment\">// kBweIncreaseIntervalMs.</span></div><div class=\"line\">      <span class=\"comment\">// Note that by remembering the bitrate over the last second one can</span></div><div class=\"line\">      <span class=\"comment\">// rampup up one second faster than if only allowed to start ramping</span></div><div class=\"line\">      <span class=\"comment\">// at 8% per second rate now. E.g.:</span></div><div class=\"line\">      <span class=\"comment\">//   If sending a constant 100kbps it can rampup immediatly to 108kbps</span></div><div class=\"line\">      <span class=\"comment\">//   whenever a receiver report is received with lower packet loss.</span></div><div class=\"line\">      <span class=\"comment\">//   If instead one would do: bitrate_ *= 1.08^(delta time), it would</span></div><div class=\"line\">      <span class=\"comment\">//   take over one second since the lower packet loss to achieve 108kbps.</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//<span class=\"doctag\">TODO:</span>tjl</span></div><div class=\"line\">\t  <span class=\"comment\">// 这里与公式有一定不同：</span></div><div class=\"line\">\t  <span class=\"comment\">// 1. 系数不同，且附带一定的修正值(向上取整加1kbps)</span></div><div class=\"line\">\t  <span class=\"comment\">// 2. 取的是上一个时间间隔之内最小值，比较平滑。</span></div><div class=\"line\">      bitrate_ = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">uint32_t</span>&gt;(</div><div class=\"line\">          min_bitrate_history_.front().second * <span class=\"number\">1.08</span> + <span class=\"number\">0.5</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// Add 1 kbps extra, just to make sure that we do not get stuck</span></div><div class=\"line\">      <span class=\"comment\">// (gives a little extra increase at low rates, negligible at higher</span></div><div class=\"line\">      <span class=\"comment\">// rates).</span></div><div class=\"line\">      bitrate_ += <span class=\"number\">1000</span>;</div><div class=\"line\"></div><div class=\"line\">      event_log_-&gt;LogBwePacketLossEvent(</div><div class=\"line\">          bitrate_, last_fraction_loss_,</div><div class=\"line\">          expected_packets_since_last_loss_update_);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (last_fraction_loss_ &lt;= <span class=\"number\">26</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// Loss between 2% - 10%: Do nothing.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// Loss &gt; 10%: Limit the rate decreases to once a kBweDecreaseIntervalMs +</span></div><div class=\"line\">      <span class=\"comment\">// rtt.</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!has_decreased_since_last_fraction_loss_ &amp;&amp;</div><div class=\"line\">          (now_ms - time_last_decrease_ms_) &gt;=</div><div class=\"line\">              (kBweDecreaseIntervalMs + last_round_trip_time_ms_)) &#123;</div><div class=\"line\">        time_last_decrease_ms_ = now_ms;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Reduce rate:</span></div><div class=\"line\">        <span class=\"comment\">//   newRate = rate * (1 - 0.5*lossRate);</span></div><div class=\"line\">        <span class=\"comment\">//   where packetLoss = 256*lossRate;</span></div><div class=\"line\">          </div><div class=\"line\">          <span class=\"comment\">//<span class=\"doctag\">TODO:</span>tjl</span></div><div class=\"line\">\t\t<span class=\"comment\">// 当从未开始降低窗口值，且距离上一次衰减的时间差大于衰减周期加上rtt。</span></div><div class=\"line\">\t\t<span class=\"comment\">// 其实当前貌似只有这个case下会对这两个变量赋值。</span></div><div class=\"line\">\t\t<span class=\"comment\">// 这里的last_fraction_loss_是一次统计间隔(一定包数)之间的总丢包率。</span></div><div class=\"line\">\t\t<span class=\"comment\">// 丢包率的单位是1/256，因此这里是(1 - 丢包率/2) * 当前速率</span></div><div class=\"line\">\t\t<span class=\"comment\">// 与公式相同。</span></div><div class=\"line\">        bitrate_ = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">uint32_t</span>&gt;(</div><div class=\"line\">            (bitrate_ * <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">double</span>&gt;(<span class=\"number\">512</span> - last_fraction_loss_)) /</div><div class=\"line\">            <span class=\"number\">512.0</span>);</div><div class=\"line\">        has_decreased_since_last_fraction_loss_ = <span class=\"literal\">true</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      event_log_-&gt;LogBwePacketLossEvent(</div><div class=\"line\">          bitrate_, last_fraction_loss_,</div><div class=\"line\">          expected_packets_since_last_loss_update_);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 在有效范围内修正。</span></div><div class=\"line\">  bitrate_ = CapBitrateToThresholds(now_ms, bitrate_);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"0-参考文档\"><a href=\"#0-参考文档\" class=\"headerlink\" title=\"0. 参考文档\"></a>0. 参考文档</h1><p>[1] <a href=\"http://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf\">google congestion control</a></p>\n<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>webrtc的带宽估计分为两部分，一部分为发送端根据rtcp反馈信息进行反馈，另一部分为接收端根据收到的rtp数据进行相应的码率估计[<a href=\"[http://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf]\">1</a>]。<br>本文先分析发送端根据rtcp反馈信息进行码率调整的部分代码。</p>\n<p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/google_congestion_control_architecture.png\" alt=\"\"></p>\n<p>具体计算公式:<br><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback.png\" alt=\"\"></p>\n<h1 id=\"2-代码结构\"><a href=\"#2-代码结构\" class=\"headerlink\" title=\"2. 代码结构\"></a>2. 代码结构</h1><h2 id=\"2-1-类关系\"><a href=\"#2-1-类关系\" class=\"headerlink\" title=\"2.1 类关系\"></a>2.1 类关系</h2><p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback_class.png\" alt=\"\"></p>\n<p>rtp_stream_receiver中有一个继承自抽象类RtpRtcp的ModuleRtpRtcpImpl，ModuleRtpRtcpImpl中有一个rtcp_receiver。当有RTCP包到来时，逐层处理至rtcp_receiver，当包是rtcp receiver report包，则会将包解析，然后在ModuleRtpRtcpImpl中再次调用rtcp_receiver中的TriggerCallbacksFromRTCPPacket函数，触发对应rtcp的一些事件，反馈触发的主要是_cbRtcpBandwidthObserver的观察者(RtcpBandwidthObserverImpl)，这个观察者收到对应的report block之后会计算成带宽估计所需要的参数，并调用属主bitratecontrolImpl类对带宽进行估计，这里会调用SendSideBandwidthEstimation中的UpdateReceiverBlock进行实际的带宽评估。</p>\n<h2 id=\"2-2-调用关系图\"><a href=\"#2-2-调用关系图\" class=\"headerlink\" title=\"2.2 调用关系图\"></a>2.2 调用关系图</h2><p><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/webrtc/rtcp_feedback_flow.png\" alt=\"\"></p>\n<h1 id=\"3-代码分析\"><a href=\"#3-代码分析\" class=\"headerlink\" title=\"3. 代码分析\"></a>3. 代码分析</h1><h2 id=\"3-1-HandleReportBlock\"><a href=\"#3-1-HandleReportBlock\" class=\"headerlink\" title=\"3.1 HandleReportBlock\"></a>3.1 HandleReportBlock</h2><p>这个函数中最主要的部分就是RTT的计算，webrtc中对于RTT平滑的因子是一个线性增长的因子。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 这个函数根据对应的report block生成了一个新的RTCPReportBlockInformation结构体，</div><div class=\"line\"> * 并计算出对应的RTT，多report block在调用点处执行循环。  */</span></div><div class=\"line\"><span class=\"keyword\">void</span> RTCPReceiver::HandleReportBlock(</div><div class=\"line\">    <span class=\"keyword\">const</span> RTCPUtility::RTCPPacket&amp; rtcpPacket,</div><div class=\"line\">    RTCPPacketInformation&amp; rtcpPacketInformation,</div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> remoteSSRC)</div><div class=\"line\">    EXCLUSIVE_LOCKS_REQUIRED(_criticalSectionRTCPReceiver) &#123;</div><div class=\"line\">  <span class=\"comment\">// This will be called once per report block in the RTCP packet.</span></div><div class=\"line\">  <span class=\"comment\">// We filter out all report blocks that are not for us.</span></div><div class=\"line\">  <span class=\"comment\">// Each packet has max 31 RR blocks.</span></div><div class=\"line\">  <span class=\"comment\">//</span></div><div class=\"line\">  <span class=\"comment\">// We can calc RTT if we send a send report and get a report block back.</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// |rtcpPacket.ReportBlockItem.SSRC| is the SSRC identifier of the source to</span></div><div class=\"line\">  <span class=\"comment\">// which the information in this reception report block pertains.</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Filter out all report blocks that are not for us.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (registered_ssrcs_.find(rtcpPacket.ReportBlockItem.SSRC) ==</div><div class=\"line\">      registered_ssrcs_.end()) &#123;</div><div class=\"line\">    <span class=\"comment\">// This block is not for us ignore it.</span></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  RTCPReportBlockInformation* reportBlock =</div><div class=\"line\">      CreateOrGetReportBlockInformation(remoteSSRC,</div><div class=\"line\">                                        rtcpPacket.ReportBlockItem.SSRC);</div><div class=\"line\">  <span class=\"keyword\">if</span> (reportBlock == <span class=\"literal\">NULL</span>) &#123;</div><div class=\"line\">    LOG(LS_WARNING) &lt;&lt; <span class=\"string\">\"Failed to CreateReportBlockInformation(\"</span></div><div class=\"line\">                    &lt;&lt; remoteSSRC &lt;&lt; <span class=\"string\">\")\"</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 用于RTCP超时的计算。</span></div><div class=\"line\">  _lastReceivedRrMs = _clock-&gt;TimeInMilliseconds();</div><div class=\"line\">  <span class=\"comment\">// 其他字段的拷贝。</span></div><div class=\"line\">  <span class=\"keyword\">const</span> RTCPPacketReportBlockItem&amp; rb = rtcpPacket.ReportBlockItem;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.remoteSSRC = remoteSSRC;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.sourceSSRC = rb.SSRC;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.fractionLost = rb.FractionLost;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.cumulativeLost =</div><div class=\"line\">      rb.CumulativeNumOfPacketsLost;</div><div class=\"line\">  <span class=\"keyword\">if</span> (rb.ExtendedHighestSequenceNumber &gt;</div><div class=\"line\">      reportBlock-&gt;remoteReceiveBlock.extendedHighSeqNum) &#123;</div><div class=\"line\">    <span class=\"comment\">// We have successfully delivered new RTP packets to the remote side after</span></div><div class=\"line\">    <span class=\"comment\">// the last RR was sent from the remote side.</span></div><div class=\"line\">    _lastIncreasedSequenceNumberMs = _lastReceivedRrMs;</div><div class=\"line\">  &#125;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.extendedHighSeqNum =</div><div class=\"line\">      rb.ExtendedHighestSequenceNumber;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.jitter = rb.Jitter;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.delaySinceLastSR = rb.DelayLastSR;</div><div class=\"line\">  reportBlock-&gt;remoteReceiveBlock.lastSR = rb.LastSR;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (rtcpPacket.ReportBlockItem.Jitter &gt; reportBlock-&gt;remoteMaxJitter) &#123;</div><div class=\"line\">    reportBlock-&gt;remoteMaxJitter = rtcpPacket.ReportBlockItem.Jitter;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">int64_t</span> rtt = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">uint32_t</span> send_time = rtcpPacket.ReportBlockItem.LastSR;</div><div class=\"line\">  <span class=\"comment\">// RFC3550, section 6.4.1, LSR field discription states:</span></div><div class=\"line\">  <span class=\"comment\">// If no SR has been received yet, the field is set to zero.</span></div><div class=\"line\">  <span class=\"comment\">// Receiver rtp_rtcp module is not expected to calculate rtt using</span></div><div class=\"line\">  <span class=\"comment\">// Sender Reports even if it accidentally can.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!receiver_only_ &amp;&amp; send_time != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t<span class=\"comment\">// 当RR在SR之前发送，send_time为0.</span></div><div class=\"line\">\t<span class=\"comment\">// delay计算:</span></div><div class=\"line\">\t<span class=\"comment\">// Send SR                                                       Receive RR</span></div><div class=\"line\">\t<span class=\"comment\">//  |                          delay in RR                           |</span></div><div class=\"line\"> \t<span class=\"comment\">//  |                        |&lt;-----------&gt;|                         |</span></div><div class=\"line\">\t<span class=\"comment\">//  |&lt;----------------------&gt;|             |&lt;-----------------------&gt;|</span></div><div class=\"line\">\t<span class=\"comment\">//</span></div><div class=\"line\">\t<span class=\"comment\">// RTT = total_time - delay_in_RR</span></div><div class=\"line\">\t<span class=\"comment\">//     = receiver_rr_time - send_sr_time - delay_in_RR</span></div><div class=\"line\">\t<span class=\"comment\">// 即使中间几个SR丢包，但是如果RTT本身是平滑的，那么RTT不会受到这几个丢包的影响</span></div><div class=\"line\">\t<span class=\"comment\">// 因为SR-&gt;RR之间的delay可以精确计算。</span></div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> delay = rtcpPacket.ReportBlockItem.DelayLastSR;</div><div class=\"line\">    <span class=\"comment\">// Local NTP time.</span></div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> receive_time = CompactNtp(NtpTime(*_clock));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// RTT in 1/(2^16) seconds.</span></div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> rtt_ntp = receive_time - delay - send_time;</div><div class=\"line\">    <span class=\"comment\">// Convert to 1/1000 seconds (milliseconds).</span></div><div class=\"line\">    rtt = CompactNtpRttToMs(rtt_ntp);</div><div class=\"line\">    <span class=\"keyword\">if</span> (rtt &gt; reportBlock-&gt;maxRTT) &#123;</div><div class=\"line\">      <span class=\"comment\">// Store max RTT.</span></div><div class=\"line\">      reportBlock-&gt;maxRTT = rtt;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (reportBlock-&gt;minRTT == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// First RTT.</span></div><div class=\"line\">      reportBlock-&gt;minRTT = rtt;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rtt &lt; reportBlock-&gt;minRTT) &#123;</div><div class=\"line\">      <span class=\"comment\">// Store min RTT.</span></div><div class=\"line\">      reportBlock-&gt;minRTT = rtt;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Store last RTT.</span></div><div class=\"line\">    reportBlock-&gt;RTT = rtt;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// store average RTT</span></div><div class=\"line\">\t<span class=\"comment\">// RTT的平滑计算。</span></div><div class=\"line\">\t<span class=\"comment\">// 如果这个块是在CreateOrGetReportBlockInformation新生成的，</span></div><div class=\"line\">\t<span class=\"comment\">// 则权重会从0开始随着受到的report逐渐递增。</span></div><div class=\"line\">\t<span class=\"comment\">// srtt(i) = i/(i+1)*srtt(i-1) + 1/(i+1)*rtt + 0.5</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (reportBlock-&gt;numAverageCalcs != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">float</span> ac = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">float</span>&gt;(reportBlock-&gt;numAverageCalcs);</div><div class=\"line\">      <span class=\"keyword\">float</span> newAverage =</div><div class=\"line\">          ((ac / (ac + <span class=\"number\">1</span>)) * reportBlock-&gt;avgRTT) + ((<span class=\"number\">1</span> / (ac + <span class=\"number\">1</span>)) * rtt);</div><div class=\"line\">      reportBlock-&gt;avgRTT = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int64_t</span>&gt;(newAverage + <span class=\"number\">0.5f</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// First RTT.</span></div><div class=\"line\">      reportBlock-&gt;avgRTT = rtt;</div><div class=\"line\">    &#125;</div><div class=\"line\">    reportBlock-&gt;numAverageCalcs++;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  TRACE_COUNTER_ID1(TRACE_DISABLED_BY_DEFAULT(<span class=\"string\">\"webrtc_rtp\"</span>), <span class=\"string\">\"RR_RTT\"</span>, rb.SSRC,</div><div class=\"line\">                    rtt);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 添加回rtcpPacketInformation，在ModuleRtpRtcpImpl中会使用这个进行事件回调。</span></div><div class=\"line\">  rtcpPacketInformation.AddReportInfo(*reportBlock);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-UpdateMinHistory\"><a href=\"#3-2-UpdateMinHistory\" class=\"headerlink\" title=\"3.2 UpdateMinHistory\"></a>3.2 UpdateMinHistory</h2><p>这个函数主要用于更新变量min_bitrate_history_，这个变量将会作用于上升区间，用来作为基数，这里简单描述下。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Updates history of min bitrates.</span></div><div class=\"line\"><span class=\"comment\">// After this method returns min_bitrate_history_.front().second contains the</span></div><div class=\"line\"><span class=\"comment\">// min bitrate used during last kBweIncreaseIntervalMs.</span></div><div class=\"line\"><span class=\"comment\">// 主要结合这个函数解释下变量min_bitrate_history_</span></div><div class=\"line\"><span class=\"comment\">// 这个变量的两个维度，front记录的是离当前最远的时间，</span></div><div class=\"line\"><span class=\"comment\">// 每个速率都是按照时间先后顺序逐渐push到尾部。</span></div><div class=\"line\"><span class=\"comment\">// 因此更新的时候，需要先将超时的元素从列表头剔除。</span></div><div class=\"line\"><span class=\"comment\">// 后一个维度是最小速率值，</span></div><div class=\"line\"><span class=\"comment\">// 在相同的时间区间内，保留最小的速率值。</span></div><div class=\"line\"><span class=\"comment\">// |-------Interval 1---------|----------Interval 2------|</span></div><div class=\"line\"><span class=\"comment\">// |                          |                          |</span></div><div class=\"line\"><span class=\"comment\">// |--t1 &lt; t2 &lt; t3 &lt; t4 &lt; t5--|--t1 &lt; t2 &lt; t3 &lt; t4 &lt; t5--|</span></div><div class=\"line\"><span class=\"comment\">// 这样的操作较为简单，不用在每次插入元素时去判断对应的时间区域，再找到对应时间区间的最小值，用部分冗余的内存换取操作的快捷。</span></div><div class=\"line\"><span class=\"keyword\">void</span> SendSideBandwidthEstimation::UpdateMinHistory(<span class=\"keyword\">int64_t</span> now_ms) &#123;</div><div class=\"line\">  <span class=\"comment\">// Remove old data points from history.</span></div><div class=\"line\">  <span class=\"comment\">// Since history precision is in ms, add one so it is able to increase</span></div><div class=\"line\">  <span class=\"comment\">// bitrate if it is off by as little as 0.5ms.</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (!min_bitrate_history_.empty() &amp;&amp;</div><div class=\"line\">         now_ms - min_bitrate_history_.front().first + <span class=\"number\">1</span> &gt;</div><div class=\"line\">             kBweIncreaseIntervalMs) &#123;</div><div class=\"line\">    min_bitrate_history_.pop_front();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Typical minimum sliding-window algorithm: Pop values higher than current</span></div><div class=\"line\">  <span class=\"comment\">// bitrate before pushing it.</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (!min_bitrate_history_.empty() &amp;&amp;</div><div class=\"line\">         bitrate_ &lt;= min_bitrate_history_.back().second) &#123;</div><div class=\"line\">    min_bitrate_history_.pop_back();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  min_bitrate_history_.push_back(<span class=\"built_in\">std</span>::make_pair(now_ms, bitrate_));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-3-UpdateEstimate\"><a href=\"#3-3-UpdateEstimate\" class=\"headerlink\" title=\"3.3 UpdateEstimate\"></a>3.3 UpdateEstimate</h2><p>函数UpdateReceiverBlock会根据当前的report block对当前带宽估计的一些变量进行相应的赋值，此外，只有当传输包的数量达到一定数量才会再次触发带宽估计的调整。函数UpdateEstimate是主要用于带宽估计的函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> SendSideBandwidthEstimation::UpdateEstimate(<span class=\"keyword\">int64_t</span> now_ms) &#123;</div><div class=\"line\">  <span class=\"comment\">// We trust the REMB and/or delay-based estimate during the first 2 seconds if</span></div><div class=\"line\">  <span class=\"comment\">// we haven't had any packet loss reported, to allow startup bitrate probing.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (last_fraction_loss_ == <span class=\"number\">0</span> &amp;&amp; IsInStartPhase(now_ms)) &#123;</div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> prev_bitrate = bitrate_;</div><div class=\"line\">\t<span class=\"comment\">// bwe_incoming_是remb更新的值，如果当前无丢包且在启动阶段，直接使用remb的值。</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (bwe_incoming_ &gt; bitrate_)</div><div class=\"line\">      bitrate_ = CapBitrateToThresholds(now_ms, bwe_incoming_);</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  UpdateMinHistory(now_ms);</div><div class=\"line\">  <span class=\"comment\">// Only start updating bitrate when receiving receiver blocks.</span></div><div class=\"line\">  <span class=\"comment\">// TODO(pbos): Handle the case when no receiver report is received for a very</span></div><div class=\"line\">  <span class=\"comment\">// long time.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (time_last_receiver_block_ms_ != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (last_fraction_loss_ &lt;= <span class=\"number\">5</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// Loss &lt; 2%: Increase rate by 8% of the min bitrate in the last</span></div><div class=\"line\">      <span class=\"comment\">// kBweIncreaseIntervalMs.</span></div><div class=\"line\">      <span class=\"comment\">// Note that by remembering the bitrate over the last second one can</span></div><div class=\"line\">      <span class=\"comment\">// rampup up one second faster than if only allowed to start ramping</span></div><div class=\"line\">      <span class=\"comment\">// at 8% per second rate now. E.g.:</span></div><div class=\"line\">      <span class=\"comment\">//   If sending a constant 100kbps it can rampup immediatly to 108kbps</span></div><div class=\"line\">      <span class=\"comment\">//   whenever a receiver report is received with lower packet loss.</span></div><div class=\"line\">      <span class=\"comment\">//   If instead one would do: bitrate_ *= 1.08^(delta time), it would</span></div><div class=\"line\">      <span class=\"comment\">//   take over one second since the lower packet loss to achieve 108kbps.</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//<span class=\"doctag\">TODO:</span>tjl</span></div><div class=\"line\">\t  <span class=\"comment\">// 这里与公式有一定不同：</span></div><div class=\"line\">\t  <span class=\"comment\">// 1. 系数不同，且附带一定的修正值(向上取整加1kbps)</span></div><div class=\"line\">\t  <span class=\"comment\">// 2. 取的是上一个时间间隔之内最小值，比较平滑。</span></div><div class=\"line\">      bitrate_ = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">uint32_t</span>&gt;(</div><div class=\"line\">          min_bitrate_history_.front().second * <span class=\"number\">1.08</span> + <span class=\"number\">0.5</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// Add 1 kbps extra, just to make sure that we do not get stuck</span></div><div class=\"line\">      <span class=\"comment\">// (gives a little extra increase at low rates, negligible at higher</span></div><div class=\"line\">      <span class=\"comment\">// rates).</span></div><div class=\"line\">      bitrate_ += <span class=\"number\">1000</span>;</div><div class=\"line\"></div><div class=\"line\">      event_log_-&gt;LogBwePacketLossEvent(</div><div class=\"line\">          bitrate_, last_fraction_loss_,</div><div class=\"line\">          expected_packets_since_last_loss_update_);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (last_fraction_loss_ &lt;= <span class=\"number\">26</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// Loss between 2% - 10%: Do nothing.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// Loss &gt; 10%: Limit the rate decreases to once a kBweDecreaseIntervalMs +</span></div><div class=\"line\">      <span class=\"comment\">// rtt.</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!has_decreased_since_last_fraction_loss_ &amp;&amp;</div><div class=\"line\">          (now_ms - time_last_decrease_ms_) &gt;=</div><div class=\"line\">              (kBweDecreaseIntervalMs + last_round_trip_time_ms_)) &#123;</div><div class=\"line\">        time_last_decrease_ms_ = now_ms;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Reduce rate:</span></div><div class=\"line\">        <span class=\"comment\">//   newRate = rate * (1 - 0.5*lossRate);</span></div><div class=\"line\">        <span class=\"comment\">//   where packetLoss = 256*lossRate;</span></div><div class=\"line\">          </div><div class=\"line\">          <span class=\"comment\">//<span class=\"doctag\">TODO:</span>tjl</span></div><div class=\"line\">\t\t<span class=\"comment\">// 当从未开始降低窗口值，且距离上一次衰减的时间差大于衰减周期加上rtt。</span></div><div class=\"line\">\t\t<span class=\"comment\">// 其实当前貌似只有这个case下会对这两个变量赋值。</span></div><div class=\"line\">\t\t<span class=\"comment\">// 这里的last_fraction_loss_是一次统计间隔(一定包数)之间的总丢包率。</span></div><div class=\"line\">\t\t<span class=\"comment\">// 丢包率的单位是1/256，因此这里是(1 - 丢包率/2) * 当前速率</span></div><div class=\"line\">\t\t<span class=\"comment\">// 与公式相同。</span></div><div class=\"line\">        bitrate_ = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">uint32_t</span>&gt;(</div><div class=\"line\">            (bitrate_ * <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">double</span>&gt;(<span class=\"number\">512</span> - last_fraction_loss_)) /</div><div class=\"line\">            <span class=\"number\">512.0</span>);</div><div class=\"line\">        has_decreased_since_last_fraction_loss_ = <span class=\"literal\">true</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      event_log_-&gt;LogBwePacketLossEvent(</div><div class=\"line\">          bitrate_, last_fraction_loss_,</div><div class=\"line\">          expected_packets_since_last_loss_update_);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 在有效范围内修正。</span></div><div class=\"line\">  bitrate_ = CapBitrateToThresholds(now_ms, bitrate_);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"九层妖塔","date":"2017-03-19T11:18:07.000Z","_content":"\n# 3只精灵龙的其他故事\n[涛哥分析的好有道理](https://algebra84.github.io/2017/03/19/threedragon/)\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/法师奥秘.jpg)\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/骑士奥秘.jpg)\n下一期涛哥应该要带来猜奥秘的模型了吧！\n\n以下代码待验证。\n``` CPP\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass tree {\n  public:\n    void build_tree (int dragon, int damage) {\n      vector<int> in; \n      in.push_back (30);\n      for (int i = 1; i < dragon + 1; i++) {\n        in.push_back (2);\n      }   \n      build_tree_1 (in, damage, 1.0);\n    }   \n\n    bool result_match (vector<int> &in) {\n      int cnt = 0;\n      for (int i = 1; i < in.size (); i++)\n        if (in[i] != 0)\n          cnt++;\n      return cnt == alive;\n    }   \n\n    void build_tree_1 (vector<int> &in, int damage, float p) {\n      int count = 0;\n      float new_p = 0.0;\n\n#ifdef DEBUG\n      for (int i = 0; i < in.size (); i++)\n        cout << in[i] << \",\";\n\n      cout << \"Prob \" << p << \" else damage \" << damage << endl;\n#endif\n\n      if (damage == 0) {\n        if (result_match (in))\n          result += p;\n        return;\n      }   \n\n      for (int i = 0; i < in.size (); i++) {\n        if (in[i] != 0)\n          count++;\n      }\n\n      if (count == 0)\n        return;\n\n      new_p = p / count;\n      count = 0;\n\n      for (int i = 0; i < in.size (); i++) {\n        /* A dead dragon.  */\n        if (in[i] == 0)\n          continue;\n\n        in[i]--;\n        build_tree_1 (in, damage - 1, new_p);\n        in[i]++;\n      }\n    }\n\n    tree (int dragon, int damage, int _alive) : alive (_alive) {\n      result = 0.0;\n      build_tree (dragon, damage);\n    }\n\n    float get_result () {\n      return result;\n    }\n\n    ~tree () {\n    }\n  private:\n    int alive;\n    float result;\n};\n\nint main ()\n{\n  tree t (3, 8, 1);\n  cout << t.get_result () << endl;\n\n  return 0;\n}\n```\n","source":"_posts/九层妖塔.md","raw":"---\ntitle: 九层妖塔\ndate: 2017-03-19 19:18:07\ntags: [涛哥说的都怼,fun]\n---\n\n# 3只精灵龙的其他故事\n[涛哥分析的好有道理](https://algebra84.github.io/2017/03/19/threedragon/)\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/法师奥秘.jpg)\n![](https://raw.githubusercontent.com/MeRcy-PM/PIC/master/骑士奥秘.jpg)\n下一期涛哥应该要带来猜奥秘的模型了吧！\n\n以下代码待验证。\n``` CPP\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass tree {\n  public:\n    void build_tree (int dragon, int damage) {\n      vector<int> in; \n      in.push_back (30);\n      for (int i = 1; i < dragon + 1; i++) {\n        in.push_back (2);\n      }   \n      build_tree_1 (in, damage, 1.0);\n    }   \n\n    bool result_match (vector<int> &in) {\n      int cnt = 0;\n      for (int i = 1; i < in.size (); i++)\n        if (in[i] != 0)\n          cnt++;\n      return cnt == alive;\n    }   \n\n    void build_tree_1 (vector<int> &in, int damage, float p) {\n      int count = 0;\n      float new_p = 0.0;\n\n#ifdef DEBUG\n      for (int i = 0; i < in.size (); i++)\n        cout << in[i] << \",\";\n\n      cout << \"Prob \" << p << \" else damage \" << damage << endl;\n#endif\n\n      if (damage == 0) {\n        if (result_match (in))\n          result += p;\n        return;\n      }   \n\n      for (int i = 0; i < in.size (); i++) {\n        if (in[i] != 0)\n          count++;\n      }\n\n      if (count == 0)\n        return;\n\n      new_p = p / count;\n      count = 0;\n\n      for (int i = 0; i < in.size (); i++) {\n        /* A dead dragon.  */\n        if (in[i] == 0)\n          continue;\n\n        in[i]--;\n        build_tree_1 (in, damage - 1, new_p);\n        in[i]++;\n      }\n    }\n\n    tree (int dragon, int damage, int _alive) : alive (_alive) {\n      result = 0.0;\n      build_tree (dragon, damage);\n    }\n\n    float get_result () {\n      return result;\n    }\n\n    ~tree () {\n    }\n  private:\n    int alive;\n    float result;\n};\n\nint main ()\n{\n  tree t (3, 8, 1);\n  cout << t.get_result () << endl;\n\n  return 0;\n}\n```\n","slug":"九层妖塔","published":1,"updated":"2017-04-06T13:56:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2gzs4jz0009r8c36a3sonnp","content":"<h1 id=\"3只精灵龙的其他故事\"><a href=\"#3只精灵龙的其他故事\" class=\"headerlink\" title=\"3只精灵龙的其他故事\"></a>3只精灵龙的其他故事</h1><p><a href=\"https://algebra84.github.io/2017/03/19/threedragon/\" target=\"_blank\" rel=\"external\">涛哥分析的好有道理</a><br><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/法师奥秘.jpg\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/骑士奥秘.jpg\" alt=\"\"><br>下一期涛哥应该要带来猜奥秘的模型了吧！</p>\n<p>以下代码待验证。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> tree &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_tree</span> <span class=\"params\">(<span class=\"keyword\">int</span> dragon, <span class=\"keyword\">int</span> damage)</span> </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; in; </div><div class=\"line\">      in.push_back (<span class=\"number\">30</span>);</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; dragon + <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">        in.push_back (<span class=\"number\">2</span>);</div><div class=\"line\">      &#125;   </div><div class=\"line\">      build_tree_1 (in, damage, <span class=\"number\">1.0</span>);</div><div class=\"line\">    &#125;   </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">result_match</span> <span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;in)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; in.size (); i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (in[i] != <span class=\"number\">0</span>)</div><div class=\"line\">          cnt++;</div><div class=\"line\">      <span class=\"keyword\">return</span> cnt == alive;</div><div class=\"line\">    &#125;   </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_tree_1</span> <span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;in, <span class=\"keyword\">int</span> damage, <span class=\"keyword\">float</span> p)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">float</span> new_p = <span class=\"number\">0.0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> DEBUG</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; in.size (); i++)</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; in[i] &lt;&lt; <span class=\"string\">\",\"</span>;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Prob \"</span> &lt;&lt; p &lt;&lt; <span class=\"string\">\" else damage \"</span> &lt;&lt; damage &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (damage == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (result_match (in))</div><div class=\"line\">          result += p;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;   </div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; in.size (); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (in[i] != <span class=\"number\">0</span>)</div><div class=\"line\">          count++;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">      new_p = p / count;</div><div class=\"line\">      count = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; in.size (); i++) &#123;</div><div class=\"line\">        <span class=\"comment\">/* A dead dragon.  */</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (in[i] == <span class=\"number\">0</span>)</div><div class=\"line\">          <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">        in[i]--;</div><div class=\"line\">        build_tree_1 (in, damage - <span class=\"number\">1</span>, new_p);</div><div class=\"line\">        in[i]++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    tree (<span class=\"keyword\">int</span> dragon, <span class=\"keyword\">int</span> damage, <span class=\"keyword\">int</span> _alive) : alive (_alive) &#123;</div><div class=\"line\">      result = <span class=\"number\">0.0</span>;</div><div class=\"line\">      build_tree (dragon, damage);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">get_result</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ~tree () &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> alive;</div><div class=\"line\">    <span class=\"keyword\">float</span> result;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"function\">tree <span class=\"title\">t</span> <span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>)</span></span>;</div><div class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; t.get_result () &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h1 id=\"3只精灵龙的其他故事\"><a href=\"#3只精灵龙的其他故事\" class=\"headerlink\" title=\"3只精灵龙的其他故事\"></a>3只精灵龙的其他故事</h1><p><a href=\"https://algebra84.github.io/2017/03/19/threedragon/\">涛哥分析的好有道理</a><br><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/法师奥秘.jpg\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/MeRcy-PM/PIC/master/骑士奥秘.jpg\" alt=\"\"><br>下一期涛哥应该要带来猜奥秘的模型了吧！</p>\n<p>以下代码待验证。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> tree &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_tree</span> <span class=\"params\">(<span class=\"keyword\">int</span> dragon, <span class=\"keyword\">int</span> damage)</span> </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; in; </div><div class=\"line\">      in.push_back (<span class=\"number\">30</span>);</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; dragon + <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">        in.push_back (<span class=\"number\">2</span>);</div><div class=\"line\">      &#125;   </div><div class=\"line\">      build_tree_1 (in, damage, <span class=\"number\">1.0</span>);</div><div class=\"line\">    &#125;   </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">result_match</span> <span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;in)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; in.size (); i++)</div><div class=\"line\">        <span class=\"keyword\">if</span> (in[i] != <span class=\"number\">0</span>)</div><div class=\"line\">          cnt++;</div><div class=\"line\">      <span class=\"keyword\">return</span> cnt == alive;</div><div class=\"line\">    &#125;   </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_tree_1</span> <span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;in, <span class=\"keyword\">int</span> damage, <span class=\"keyword\">float</span> p)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">float</span> new_p = <span class=\"number\">0.0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> DEBUG</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; in.size (); i++)</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; in[i] &lt;&lt; <span class=\"string\">\",\"</span>;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Prob \"</span> &lt;&lt; p &lt;&lt; <span class=\"string\">\" else damage \"</span> &lt;&lt; damage &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (damage == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (result_match (in))</div><div class=\"line\">          result += p;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;   </div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; in.size (); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (in[i] != <span class=\"number\">0</span>)</div><div class=\"line\">          count++;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">      new_p = p / count;</div><div class=\"line\">      count = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; in.size (); i++) &#123;</div><div class=\"line\">        <span class=\"comment\">/* A dead dragon.  */</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (in[i] == <span class=\"number\">0</span>)</div><div class=\"line\">          <span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">        in[i]--;</div><div class=\"line\">        build_tree_1 (in, damage - <span class=\"number\">1</span>, new_p);</div><div class=\"line\">        in[i]++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    tree (<span class=\"keyword\">int</span> dragon, <span class=\"keyword\">int</span> damage, <span class=\"keyword\">int</span> _alive) : alive (_alive) &#123;</div><div class=\"line\">      result = <span class=\"number\">0.0</span>;</div><div class=\"line\">      build_tree (dragon, damage);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">get_result</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ~tree () &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> alive;</div><div class=\"line\">    <span class=\"keyword\">float</span> result;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">  <span class=\"function\">tree <span class=\"title\">t</span> <span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>)</span></span>;</div><div class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; t.get_result () &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"linux内核慢启动拥塞避免代码分析","date":"2017-03-27T02:27:29.000Z","_content":"\n@(Network)[tcp, 慢启动]\n# TCP拥塞控制两个速率增长阶段分析\n# 0. 参考文档\n\\[1\\] [rfc-5681](https://tools.ietf.org/html/rfc5681)\n\\[2\\] [tcp-abc-rfc](http://blog.csdn.net/dog250/article/details/51348568)\n\\[3\\] [rfc-3465](https://tools.ietf.org/html/rfc3465)\n\\[4\\] [rfc-3742](https://tools.ietf.org/html/rfc3742)\n\n# 1. 拥塞控制个人理解\n\n## 1.1 慢启动与拥塞避免\n慢启动和拥塞避免，主要是用于拥塞控制中拥塞窗口增长的维护。\n\n根据阈值，拥塞控制其实分为两部分，小于阈值的慢启动阶段，大于阈值进入拥塞避免阶段。\n\n慢启动作为拥塞控制的一部分，我觉得其名字取的比较具有混淆性。个人理解的慢启动分为两种，一种是拥塞窗口小于阈值时候正常的一个指数增长的过程，这个过程中的拥塞窗口不会重置，会持续增长，还有一种是与快速恢复对应的慢启动重新启动，这种时候会将拥塞窗口重置为1，并重新开始指数增长。这么理解的原因如下：\n\n在[文档][1]中描述快速恢复时，当收到三个重复ack时候，这时候可能并不是实际丢包，可能是因为链路问题，较晚到达接收端。\n\n- 在BSD 4.3之前会进入慢启动阶段，但是理论上慢启动一般是指数上升的过程，反而是拥塞避免阶段线性上升速度较慢，且拥塞避免会更新当前的拥塞窗口和阈值，会出现小范围衰减。\n- 假如tcp认为当前包丢失，会很严格的重置拥塞窗口(具体代码如rto触发tcp\\_enter\\_loss)，这时候速率曲线不会只是单纯减低到某个值，而是会降低到零点。\n\n## 1.2 快速恢复和快速重传\n因此，个人理解，老版本上收到三个重复ack认为丢包，进入丢包处理，重置了拥塞窗口，在非重复ack到来后，拥塞窗口仍然需要从零开始指数上升，而对于快速恢复而言，其只进入拥塞避免阶段，拥塞窗口只是进行一定修正，在非重复ack到来后，仍然能根据阈值来决定是否执行非重启的慢启动，这时候恢复速度相较于严格的丢包处理快了不少。\n\n由于tcp对于丢包的容忍极低，一旦丢包发生，就会进入严格的拥塞处理，而RTO是丢包主要判断依据，因此快速重传也是针对tcp对于丢包容忍度低的一个修正，避免进入RTO，直接影响传输性能。\n\n# 2. 拥塞控制代码分析\n本章主要基于reno的拥塞控制。下文中的代码均基于linux kernel 2.6.32版本，直到linux kernel 4.9-rc8之前的版本，tcp整体并没有太大变化。本文不分析frto相关内容。\n\n## 2.1 调用链\n由于文档描述上是直接给出一个计算过程，如慢启动阶段的指数上升，和代码直观上看略有不同，因此这里需要先缕清楚整个的调用链，能更好的描述整个拥塞控制的过程。\n\ntcp的拥塞主要是基于定时器(RTO)和ack的，因此主要处理函数都以tcp\\_ack为起点。这里不分析整个tcp\\_ack函数，仅分析常规调用链。\n\n整体入口如下：\n\n```cpp\n// 当ack时一个可疑的ack，如sack，或者路由发送的显示拥塞控制，或者当前拥塞状态不是正常状态时。\nif (tcp_ack_is_dubious(sk, flag)) {\n\t/* Advance CWND, if state allows this. */\n\tif ((flag & FLAG_DATA_ACKED) && !frto_cwnd &&\n\t    tcp_may_raise_cwnd(sk, flag))\n\t    // 当窗口仍然满足可以增长的条件时，进入拥塞控制，\n\t    // 这是一个钩子函数，具体实现由具体拥塞控制算法来实现，\n\t    // 对于reno而言可能是慢启动，可能是拥塞避免。\n\t\ttcp_cong_avoid(sk, ack, prior_in_flight);\n\t// 处理拥塞状态机，暂时不展开\n\ttcp_fastretrans_alert(sk, prior_packets - tp->packets_out,\n\t\t\t      flag);\n} else {\n    // 当这个ack是一个正常的数据确认包，进入拥塞控制\n\tif ((flag & FLAG_DATA_ACKED) && !frto_cwnd)\n\t\ttcp_cong_avoid(sk, ack, prior_in_flight);\n}\n```\n\n## 2.2 tcp reno的拥塞控制\ntcp reno注册到拥塞控制框架中的是tcp\\_reno\\_cong\\_avoid函数。\n\n其代码较为简单，只是其中多了一部分tcp-abc的拥塞避免算法，其慢启动实现在tcp\\_slow\\_start中，可以参考\\[[rfc-3465][3]\\]\\[[tcp_abc][2]\\]。大体是用已经确认的byte大小来作为拥塞控制的计算，在慢启动阶段会更加激进，但是可能会带来更大的burst。\n\n```cpp\n/*\n * TCP Reno congestion control\n * This is special case used for fallback as well.\n */\n/* This is Jacobson's slow start and congestion avoidance.\n * SIGCOMM '88, p. 328.\n */\nvoid tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (!tcp_is_cwnd_limited(sk, in_flight))\n\t\treturn;\n\n\t/* In \"safe\" area, increase. */\n\t// 小于阈值会进入慢启动环节，不重置窗口的慢启动。\n\tif (tp->snd_cwnd <= tp->snd_ssthresh)\n\t\ttcp_slow_start(tp);\n\n\t/* In dangerous area, increase slowly. */\n\telse if (sysctl_tcp_abc) {\n\t\t/* RFC3465: Appropriate Byte Count\n\t\t * increase once for each full cwnd acked\n\t\t */\n\t\t// RFC3465的拥塞避免算法，使用bytes_acked来作为修改拥塞窗口的判断条件\n\t\tif (tp->bytes_acked >= tp->snd_cwnd*tp->mss_cache) {\n\t\t\ttp->bytes_acked -= tp->snd_cwnd*tp->mss_cache;\n\t\t\tif (tp->snd_cwnd < tp->snd_cwnd_clamp)\n\t\t\t\ttp->snd_cwnd++;\n\t\t}\n\t} else {\n\t    // 拥塞避免\n\t\ttcp_cong_avoid_ai(tp, tp->snd_cwnd);\n\t}\n}\n```\n\n## 2.3 慢启动\n慢启动里面额外涉及两篇rfc，[rfc-3742][4]和[tcp_abc][3]。\n\n其中snd\\_cwnd\\_cnt为线性增长器，只有当线性增长器大于一个窗口大小时，其才会将发送窗口增加，即其单位为1/snd\\_cwnd，后续还会在拥塞避免代码中见到。\n\n刚开始看代码时对下面那个循环并不是很理解，不理解为什么++是指数增长，直到放到整个调用栈上看，其具体流程如代码注释中所写，为指数增长的过程。\n\n```cpp\n/*\n * Slow start is used when congestion window is less than slow start\n * threshold. This version implements the basic RFC2581 version\n * and optionally supports:\n * \tRFC3742 Limited Slow Start  \t  - growth limited to max_ssthresh\n *\tRFC3465 Appropriate Byte Counting - growth limited by bytes acknowledged\n */\nvoid tcp_slow_start(struct tcp_sock *tp)\n{\n\tint cnt; /* increase in packets */\n\n\t/* RFC3465: ABC Slow start\n\t * Increase only after a full MSS of bytes is acked\n\t *\n\t * TCP sender SHOULD increase cwnd by the number of\n\t * previously unacknowledged bytes ACKed by each incoming\n\t * acknowledgment, provided the increase is not more than L\n\t */\n    // 不满足tcp abc的窗口增加条件，此时确认的字节数小于mss_cache。\n\tif (sysctl_tcp_abc && tp->bytes_acked < tp->mss_cache)\n\t\treturn;\n\n    // RFC 3742，限制慢启动在一个RTT内的burst。\n\tif (sysctl_tcp_max_ssthresh > 0 && tp->snd_cwnd > sysctl_tcp_max_ssthresh)\n\t\tcnt = sysctl_tcp_max_ssthresh >> 1;\t/* limited slow start */\n\telse\n\t// 加上一个窗口大小，在没有abc的情况，保证在最底下的循环中拥塞窗口大小至少增加1.\n\t\tcnt = tp->snd_cwnd;\t\t\t/* exponential increase */\n\n\t/* RFC3465: ABC\n\t * We MAY increase by 2 if discovered delayed ack\n\t */\n\t// tcp-abc，慢启动阶段更激进的burst。\n\tif (sysctl_tcp_abc > 1 && tp->bytes_acked >= 2*tp->mss_cache)\n\t\tcnt <<= 1;\n\ttp->bytes_acked = 0;\n\n    // 更新snd_cwnd_cnt(窗口线性增长器)\n    tp->snd_cwnd_cnt += cnt;\n    // 线性增长器是窗口的多少倍，窗口就增加多少。\n    // 注意：这里的标准场景下的线性增长，每次也只增长1个窗口大小，\n    // 但是其仍然是指数增长，因此每个窗口发出去的数据对应一个ack，\n    // 而每一个ack都会对应触发一次增长。\n    // 以下为一个简单的例子，sender为发送端，receiver为接收端\n    // px为包号为x的包，ack x为对第x个包的确认\n    // snd_cwnd为拥塞窗口\n    // sender                                           receiver\n    //  p1 (snd_cwnd 1)  --------------------------->\n    //    \n    //                   <---------------------------     ack 1\n    //  snd_cwnd++ (2)\n    //\n    //  p2 (snd_cwnd 2)  --------------------------->\n    //  p3 (snd_cwnd 2)  ---------------------------> \n    //\n    //                   <---------------------------     ack 2\n    //  snd_cwnd++ (3)\n    //                   <---------------------------     ack 3\n    //  snd_cwnd++ (4)\n    //\n    //  p4 (snd_cwnd 4)  --------------------------->\n    //  p5 (snd_cwnd 4)  --------------------------->\n    //  p6 (snd_cwnd 4)  --------------------------->\n    //  p7 (snd_cwnd 4)  --------------------------->\n    //\n    //                   <---------------------------     ack 4\n    //  snd_cwnd++ (5)\n    //                   <---------------------------     ack 5\n    //  snd_cwnd++ (6)\n    //                   <---------------------------     ack 6\n    //  snd_cwnd++ (7)\n    //                   <---------------------------     ack 7\n    //  snd_cwnd++ (8)\n    //  send with snd_cwnd = 8 (p8 - p15)\n    // 每一个ack对应增加一个窗口大小，不丢包的场景下相当于窗口以指数上升\n    // 1 --> 2 --> 4 --> 8\n\twhile (tp->snd_cwnd_cnt >= tp->snd_cwnd) {\n\t\ttp->snd_cwnd_cnt -= tp->snd_cwnd;\n\t\tif (tp->snd_cwnd < tp->snd_cwnd_clamp)\n\t\t\ttp->snd_cwnd++;\n\t}\n}\n```\n\n## 2.4 拥塞避免\n拥塞避免的代码比较简短，注意2.3中所写的，snd\\_cwnd\\_cnt为线性增长器，其单位为1 / w。在reno调用中，这里的w也为snd\\_cwnd窗口大小。即每一个ack只增加1 / snd_\\cwnd大小的窗口。\n\n```cpp\n/* In theory this is tp->snd_cwnd += 1 / tp->snd_cwnd (or alternative w) */\nvoid tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w)\n{\n    // 每次cnt++，直到w次后snd_cwnd++，即单位 1 / w\n\tif (tp->snd_cwnd_cnt >= w) {\n\t\tif (tp->snd_cwnd < tp->snd_cwnd_clamp)\n\t\t\ttp->snd_cwnd++;\n\t\ttp->snd_cwnd_cnt = 0;\n\t} else {\n\t\ttp->snd_cwnd_cnt++;\n\t}\n}\n```\n\n# 3. kernel 4.9的改变\n对tcp\\_slow\\_start的改动不算是4.9的，早在3.18之前就已经改变了，使用的已经不是之前的snd\\_cwnd\\_cnt，而是采用tcp-abc算法来进行慢启动。\n\n慢启动仍然使用类似tcp-abc的实现机制，不过其并不以byte作为单位，而是以MSS作为单位进行处理。\n```cpp\n/* Slow start is used when congestion window is no greater than the slow start\n * threshold. We base on RFC2581 and also handle stretch ACKs properly.\n * We do not implement RFC3465 Appropriate Byte Counting (ABC) per se but\n * something better;) a packet is only considered (s)acked in its entirety to\n * defend the ACK attacks described in the RFC. Slow start processes a stretch\n * ACK of degree N as if N acks of degree 1 are received back to back except\n * ABC caps N to 2. Slow start exits when cwnd grows over ssthresh and\n * returns the leftover acks to adjust cwnd in congestion avoidance mode.\n */\nu32 tcp_slow_start(struct tcp_sock *tp, u32 acked)\n{\n    // 使用确认的包数(其中可能包括sack的确认，或者重传数据的确认都加上)\n    // 来更新窗口值，而不是之前的byte。\n    // 在函数tcp_clean_rtx_queue中有更新对应的delivered。\n    // 其更新的值貌似和MSS有关系。\n\tu32 cwnd = min(tp->snd_cwnd + acked, tp->snd_ssthresh);\n\n    // 当acked仍然有值，说明超过阈值，处理完slow start后还会进行congestion avoid的处理。\n\tacked -= cwnd - tp->snd_cwnd;\n\ttp->snd_cwnd = min(cwnd, tp->snd_cwnd_clamp);\n\n\treturn acked;\n}\n```\n\n拥塞避免上和老版本类似，也使用到了线性增长器，但是涨幅比之前版本较大，并不是以1为计数，而是以acked，即已经确认的MSS个数据片作为单位。\n\n```cpp\n/* In theory this is tp->snd_cwnd += 1 / tp->snd_cwnd (or alternative w),\n * for every packet that was ACKed.\n */\nvoid tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w, u32 acked)\n{\n\t/* If credits accumulated at a higher w, apply them gently now. */\n\t// 第一次线性增长计算。\n\tif (tp->snd_cwnd_cnt >= w) {\n\t\ttp->snd_cwnd_cnt = 0;\n\t\ttp->snd_cwnd++;\n\t}\n\n    // 以 acked / snd_cwnd为单位增长。将循环改为除法。\n\ttp->snd_cwnd_cnt += acked;\n\tif (tp->snd_cwnd_cnt >= w) {\n\t\tu32 delta = tp->snd_cwnd_cnt / w;\n\n\t\ttp->snd_cwnd_cnt -= delta * w;\n\t\ttp->snd_cwnd += delta;\n\t}\n\ttp->snd_cwnd = min(tp->snd_cwnd, tp->snd_cwnd_clamp);\n}\n```\n\n@小刘\n```\n悦\n```\n\n\n[1]: https://tools.ietf.org/html/rfc5681\n[2]: http://blog.csdn.net/dog250/article/details/51348568\n[3]: https://tools.ietf.org/html/rfc3465\n[4]: https://tools.ietf.org/html/rfc3742\n","source":"_posts/linux内核慢启动拥塞避免代码分析.md","raw":"---\ntitle: linux内核慢启动拥塞避免代码分析\ndate: 2017-03-27 10:27:29\ntags: [TCP, linux, 拥塞控制]\n---\n\n@(Network)[tcp, 慢启动]\n# TCP拥塞控制两个速率增长阶段分析\n# 0. 参考文档\n\\[1\\] [rfc-5681](https://tools.ietf.org/html/rfc5681)\n\\[2\\] [tcp-abc-rfc](http://blog.csdn.net/dog250/article/details/51348568)\n\\[3\\] [rfc-3465](https://tools.ietf.org/html/rfc3465)\n\\[4\\] [rfc-3742](https://tools.ietf.org/html/rfc3742)\n\n# 1. 拥塞控制个人理解\n\n## 1.1 慢启动与拥塞避免\n慢启动和拥塞避免，主要是用于拥塞控制中拥塞窗口增长的维护。\n\n根据阈值，拥塞控制其实分为两部分，小于阈值的慢启动阶段，大于阈值进入拥塞避免阶段。\n\n慢启动作为拥塞控制的一部分，我觉得其名字取的比较具有混淆性。个人理解的慢启动分为两种，一种是拥塞窗口小于阈值时候正常的一个指数增长的过程，这个过程中的拥塞窗口不会重置，会持续增长，还有一种是与快速恢复对应的慢启动重新启动，这种时候会将拥塞窗口重置为1，并重新开始指数增长。这么理解的原因如下：\n\n在[文档][1]中描述快速恢复时，当收到三个重复ack时候，这时候可能并不是实际丢包，可能是因为链路问题，较晚到达接收端。\n\n- 在BSD 4.3之前会进入慢启动阶段，但是理论上慢启动一般是指数上升的过程，反而是拥塞避免阶段线性上升速度较慢，且拥塞避免会更新当前的拥塞窗口和阈值，会出现小范围衰减。\n- 假如tcp认为当前包丢失，会很严格的重置拥塞窗口(具体代码如rto触发tcp\\_enter\\_loss)，这时候速率曲线不会只是单纯减低到某个值，而是会降低到零点。\n\n## 1.2 快速恢复和快速重传\n因此，个人理解，老版本上收到三个重复ack认为丢包，进入丢包处理，重置了拥塞窗口，在非重复ack到来后，拥塞窗口仍然需要从零开始指数上升，而对于快速恢复而言，其只进入拥塞避免阶段，拥塞窗口只是进行一定修正，在非重复ack到来后，仍然能根据阈值来决定是否执行非重启的慢启动，这时候恢复速度相较于严格的丢包处理快了不少。\n\n由于tcp对于丢包的容忍极低，一旦丢包发生，就会进入严格的拥塞处理，而RTO是丢包主要判断依据，因此快速重传也是针对tcp对于丢包容忍度低的一个修正，避免进入RTO，直接影响传输性能。\n\n# 2. 拥塞控制代码分析\n本章主要基于reno的拥塞控制。下文中的代码均基于linux kernel 2.6.32版本，直到linux kernel 4.9-rc8之前的版本，tcp整体并没有太大变化。本文不分析frto相关内容。\n\n## 2.1 调用链\n由于文档描述上是直接给出一个计算过程，如慢启动阶段的指数上升，和代码直观上看略有不同，因此这里需要先缕清楚整个的调用链，能更好的描述整个拥塞控制的过程。\n\ntcp的拥塞主要是基于定时器(RTO)和ack的，因此主要处理函数都以tcp\\_ack为起点。这里不分析整个tcp\\_ack函数，仅分析常规调用链。\n\n整体入口如下：\n\n```cpp\n// 当ack时一个可疑的ack，如sack，或者路由发送的显示拥塞控制，或者当前拥塞状态不是正常状态时。\nif (tcp_ack_is_dubious(sk, flag)) {\n\t/* Advance CWND, if state allows this. */\n\tif ((flag & FLAG_DATA_ACKED) && !frto_cwnd &&\n\t    tcp_may_raise_cwnd(sk, flag))\n\t    // 当窗口仍然满足可以增长的条件时，进入拥塞控制，\n\t    // 这是一个钩子函数，具体实现由具体拥塞控制算法来实现，\n\t    // 对于reno而言可能是慢启动，可能是拥塞避免。\n\t\ttcp_cong_avoid(sk, ack, prior_in_flight);\n\t// 处理拥塞状态机，暂时不展开\n\ttcp_fastretrans_alert(sk, prior_packets - tp->packets_out,\n\t\t\t      flag);\n} else {\n    // 当这个ack是一个正常的数据确认包，进入拥塞控制\n\tif ((flag & FLAG_DATA_ACKED) && !frto_cwnd)\n\t\ttcp_cong_avoid(sk, ack, prior_in_flight);\n}\n```\n\n## 2.2 tcp reno的拥塞控制\ntcp reno注册到拥塞控制框架中的是tcp\\_reno\\_cong\\_avoid函数。\n\n其代码较为简单，只是其中多了一部分tcp-abc的拥塞避免算法，其慢启动实现在tcp\\_slow\\_start中，可以参考\\[[rfc-3465][3]\\]\\[[tcp_abc][2]\\]。大体是用已经确认的byte大小来作为拥塞控制的计算，在慢启动阶段会更加激进，但是可能会带来更大的burst。\n\n```cpp\n/*\n * TCP Reno congestion control\n * This is special case used for fallback as well.\n */\n/* This is Jacobson's slow start and congestion avoidance.\n * SIGCOMM '88, p. 328.\n */\nvoid tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (!tcp_is_cwnd_limited(sk, in_flight))\n\t\treturn;\n\n\t/* In \"safe\" area, increase. */\n\t// 小于阈值会进入慢启动环节，不重置窗口的慢启动。\n\tif (tp->snd_cwnd <= tp->snd_ssthresh)\n\t\ttcp_slow_start(tp);\n\n\t/* In dangerous area, increase slowly. */\n\telse if (sysctl_tcp_abc) {\n\t\t/* RFC3465: Appropriate Byte Count\n\t\t * increase once for each full cwnd acked\n\t\t */\n\t\t// RFC3465的拥塞避免算法，使用bytes_acked来作为修改拥塞窗口的判断条件\n\t\tif (tp->bytes_acked >= tp->snd_cwnd*tp->mss_cache) {\n\t\t\ttp->bytes_acked -= tp->snd_cwnd*tp->mss_cache;\n\t\t\tif (tp->snd_cwnd < tp->snd_cwnd_clamp)\n\t\t\t\ttp->snd_cwnd++;\n\t\t}\n\t} else {\n\t    // 拥塞避免\n\t\ttcp_cong_avoid_ai(tp, tp->snd_cwnd);\n\t}\n}\n```\n\n## 2.3 慢启动\n慢启动里面额外涉及两篇rfc，[rfc-3742][4]和[tcp_abc][3]。\n\n其中snd\\_cwnd\\_cnt为线性增长器，只有当线性增长器大于一个窗口大小时，其才会将发送窗口增加，即其单位为1/snd\\_cwnd，后续还会在拥塞避免代码中见到。\n\n刚开始看代码时对下面那个循环并不是很理解，不理解为什么++是指数增长，直到放到整个调用栈上看，其具体流程如代码注释中所写，为指数增长的过程。\n\n```cpp\n/*\n * Slow start is used when congestion window is less than slow start\n * threshold. This version implements the basic RFC2581 version\n * and optionally supports:\n * \tRFC3742 Limited Slow Start  \t  - growth limited to max_ssthresh\n *\tRFC3465 Appropriate Byte Counting - growth limited by bytes acknowledged\n */\nvoid tcp_slow_start(struct tcp_sock *tp)\n{\n\tint cnt; /* increase in packets */\n\n\t/* RFC3465: ABC Slow start\n\t * Increase only after a full MSS of bytes is acked\n\t *\n\t * TCP sender SHOULD increase cwnd by the number of\n\t * previously unacknowledged bytes ACKed by each incoming\n\t * acknowledgment, provided the increase is not more than L\n\t */\n    // 不满足tcp abc的窗口增加条件，此时确认的字节数小于mss_cache。\n\tif (sysctl_tcp_abc && tp->bytes_acked < tp->mss_cache)\n\t\treturn;\n\n    // RFC 3742，限制慢启动在一个RTT内的burst。\n\tif (sysctl_tcp_max_ssthresh > 0 && tp->snd_cwnd > sysctl_tcp_max_ssthresh)\n\t\tcnt = sysctl_tcp_max_ssthresh >> 1;\t/* limited slow start */\n\telse\n\t// 加上一个窗口大小，在没有abc的情况，保证在最底下的循环中拥塞窗口大小至少增加1.\n\t\tcnt = tp->snd_cwnd;\t\t\t/* exponential increase */\n\n\t/* RFC3465: ABC\n\t * We MAY increase by 2 if discovered delayed ack\n\t */\n\t// tcp-abc，慢启动阶段更激进的burst。\n\tif (sysctl_tcp_abc > 1 && tp->bytes_acked >= 2*tp->mss_cache)\n\t\tcnt <<= 1;\n\ttp->bytes_acked = 0;\n\n    // 更新snd_cwnd_cnt(窗口线性增长器)\n    tp->snd_cwnd_cnt += cnt;\n    // 线性增长器是窗口的多少倍，窗口就增加多少。\n    // 注意：这里的标准场景下的线性增长，每次也只增长1个窗口大小，\n    // 但是其仍然是指数增长，因此每个窗口发出去的数据对应一个ack，\n    // 而每一个ack都会对应触发一次增长。\n    // 以下为一个简单的例子，sender为发送端，receiver为接收端\n    // px为包号为x的包，ack x为对第x个包的确认\n    // snd_cwnd为拥塞窗口\n    // sender                                           receiver\n    //  p1 (snd_cwnd 1)  --------------------------->\n    //    \n    //                   <---------------------------     ack 1\n    //  snd_cwnd++ (2)\n    //\n    //  p2 (snd_cwnd 2)  --------------------------->\n    //  p3 (snd_cwnd 2)  ---------------------------> \n    //\n    //                   <---------------------------     ack 2\n    //  snd_cwnd++ (3)\n    //                   <---------------------------     ack 3\n    //  snd_cwnd++ (4)\n    //\n    //  p4 (snd_cwnd 4)  --------------------------->\n    //  p5 (snd_cwnd 4)  --------------------------->\n    //  p6 (snd_cwnd 4)  --------------------------->\n    //  p7 (snd_cwnd 4)  --------------------------->\n    //\n    //                   <---------------------------     ack 4\n    //  snd_cwnd++ (5)\n    //                   <---------------------------     ack 5\n    //  snd_cwnd++ (6)\n    //                   <---------------------------     ack 6\n    //  snd_cwnd++ (7)\n    //                   <---------------------------     ack 7\n    //  snd_cwnd++ (8)\n    //  send with snd_cwnd = 8 (p8 - p15)\n    // 每一个ack对应增加一个窗口大小，不丢包的场景下相当于窗口以指数上升\n    // 1 --> 2 --> 4 --> 8\n\twhile (tp->snd_cwnd_cnt >= tp->snd_cwnd) {\n\t\ttp->snd_cwnd_cnt -= tp->snd_cwnd;\n\t\tif (tp->snd_cwnd < tp->snd_cwnd_clamp)\n\t\t\ttp->snd_cwnd++;\n\t}\n}\n```\n\n## 2.4 拥塞避免\n拥塞避免的代码比较简短，注意2.3中所写的，snd\\_cwnd\\_cnt为线性增长器，其单位为1 / w。在reno调用中，这里的w也为snd\\_cwnd窗口大小。即每一个ack只增加1 / snd_\\cwnd大小的窗口。\n\n```cpp\n/* In theory this is tp->snd_cwnd += 1 / tp->snd_cwnd (or alternative w) */\nvoid tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w)\n{\n    // 每次cnt++，直到w次后snd_cwnd++，即单位 1 / w\n\tif (tp->snd_cwnd_cnt >= w) {\n\t\tif (tp->snd_cwnd < tp->snd_cwnd_clamp)\n\t\t\ttp->snd_cwnd++;\n\t\ttp->snd_cwnd_cnt = 0;\n\t} else {\n\t\ttp->snd_cwnd_cnt++;\n\t}\n}\n```\n\n# 3. kernel 4.9的改变\n对tcp\\_slow\\_start的改动不算是4.9的，早在3.18之前就已经改变了，使用的已经不是之前的snd\\_cwnd\\_cnt，而是采用tcp-abc算法来进行慢启动。\n\n慢启动仍然使用类似tcp-abc的实现机制，不过其并不以byte作为单位，而是以MSS作为单位进行处理。\n```cpp\n/* Slow start is used when congestion window is no greater than the slow start\n * threshold. We base on RFC2581 and also handle stretch ACKs properly.\n * We do not implement RFC3465 Appropriate Byte Counting (ABC) per se but\n * something better;) a packet is only considered (s)acked in its entirety to\n * defend the ACK attacks described in the RFC. Slow start processes a stretch\n * ACK of degree N as if N acks of degree 1 are received back to back except\n * ABC caps N to 2. Slow start exits when cwnd grows over ssthresh and\n * returns the leftover acks to adjust cwnd in congestion avoidance mode.\n */\nu32 tcp_slow_start(struct tcp_sock *tp, u32 acked)\n{\n    // 使用确认的包数(其中可能包括sack的确认，或者重传数据的确认都加上)\n    // 来更新窗口值，而不是之前的byte。\n    // 在函数tcp_clean_rtx_queue中有更新对应的delivered。\n    // 其更新的值貌似和MSS有关系。\n\tu32 cwnd = min(tp->snd_cwnd + acked, tp->snd_ssthresh);\n\n    // 当acked仍然有值，说明超过阈值，处理完slow start后还会进行congestion avoid的处理。\n\tacked -= cwnd - tp->snd_cwnd;\n\ttp->snd_cwnd = min(cwnd, tp->snd_cwnd_clamp);\n\n\treturn acked;\n}\n```\n\n拥塞避免上和老版本类似，也使用到了线性增长器，但是涨幅比之前版本较大，并不是以1为计数，而是以acked，即已经确认的MSS个数据片作为单位。\n\n```cpp\n/* In theory this is tp->snd_cwnd += 1 / tp->snd_cwnd (or alternative w),\n * for every packet that was ACKed.\n */\nvoid tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w, u32 acked)\n{\n\t/* If credits accumulated at a higher w, apply them gently now. */\n\t// 第一次线性增长计算。\n\tif (tp->snd_cwnd_cnt >= w) {\n\t\ttp->snd_cwnd_cnt = 0;\n\t\ttp->snd_cwnd++;\n\t}\n\n    // 以 acked / snd_cwnd为单位增长。将循环改为除法。\n\ttp->snd_cwnd_cnt += acked;\n\tif (tp->snd_cwnd_cnt >= w) {\n\t\tu32 delta = tp->snd_cwnd_cnt / w;\n\n\t\ttp->snd_cwnd_cnt -= delta * w;\n\t\ttp->snd_cwnd += delta;\n\t}\n\ttp->snd_cwnd = min(tp->snd_cwnd, tp->snd_cwnd_clamp);\n}\n```\n\n@小刘\n```\n悦\n```\n\n\n[1]: https://tools.ietf.org/html/rfc5681\n[2]: http://blog.csdn.net/dog250/article/details/51348568\n[3]: https://tools.ietf.org/html/rfc3465\n[4]: https://tools.ietf.org/html/rfc3742\n","slug":"linux内核慢启动拥塞避免代码分析","published":1,"updated":"2017-05-11T02:29:39.000Z","_id":"cj2gzs4k0000ar8c35zl4e115","comments":1,"layout":"post","photos":[],"link":"","content":"<p>@(Network)[tcp, 慢启动]</p>\n<h1 id=\"TCP拥塞控制两个速率增长阶段分析\"><a href=\"#TCP拥塞控制两个速率增长阶段分析\" class=\"headerlink\" title=\"TCP拥塞控制两个速率增长阶段分析\"></a>TCP拥塞控制两个速率增长阶段分析</h1><h1 id=\"0-参考文档\"><a href=\"#0-参考文档\" class=\"headerlink\" title=\"0. 参考文档\"></a>0. 参考文档</h1><p>[1] <a href=\"https://tools.ietf.org/html/rfc5681\" target=\"_blank\" rel=\"external\">rfc-5681</a><br>[2] <a href=\"http://blog.csdn.net/dog250/article/details/51348568\" target=\"_blank\" rel=\"external\">tcp-abc-rfc</a><br>[3] <a href=\"https://tools.ietf.org/html/rfc3465\" target=\"_blank\" rel=\"external\">rfc-3465</a><br>[4] <a href=\"https://tools.ietf.org/html/rfc3742\" target=\"_blank\" rel=\"external\">rfc-3742</a></p>\n<h1 id=\"1-拥塞控制个人理解\"><a href=\"#1-拥塞控制个人理解\" class=\"headerlink\" title=\"1. 拥塞控制个人理解\"></a>1. 拥塞控制个人理解</h1><h2 id=\"1-1-慢启动与拥塞避免\"><a href=\"#1-1-慢启动与拥塞避免\" class=\"headerlink\" title=\"1.1 慢启动与拥塞避免\"></a>1.1 慢启动与拥塞避免</h2><p>慢启动和拥塞避免，主要是用于拥塞控制中拥塞窗口增长的维护。</p>\n<p>根据阈值，拥塞控制其实分为两部分，小于阈值的慢启动阶段，大于阈值进入拥塞避免阶段。</p>\n<p>慢启动作为拥塞控制的一部分，我觉得其名字取的比较具有混淆性。个人理解的慢启动分为两种，一种是拥塞窗口小于阈值时候正常的一个指数增长的过程，这个过程中的拥塞窗口不会重置，会持续增长，还有一种是与快速恢复对应的慢启动重新启动，这种时候会将拥塞窗口重置为1，并重新开始指数增长。这么理解的原因如下：</p>\n<p>在<a href=\"https://tools.ietf.org/html/rfc5681\" target=\"_blank\" rel=\"external\">文档</a>中描述快速恢复时，当收到三个重复ack时候，这时候可能并不是实际丢包，可能是因为链路问题，较晚到达接收端。</p>\n<ul>\n<li>在BSD 4.3之前会进入慢启动阶段，但是理论上慢启动一般是指数上升的过程，反而是拥塞避免阶段线性上升速度较慢，且拥塞避免会更新当前的拥塞窗口和阈值，会出现小范围衰减。</li>\n<li>假如tcp认为当前包丢失，会很严格的重置拥塞窗口(具体代码如rto触发tcp_enter_loss)，这时候速率曲线不会只是单纯减低到某个值，而是会降低到零点。</li>\n</ul>\n<h2 id=\"1-2-快速恢复和快速重传\"><a href=\"#1-2-快速恢复和快速重传\" class=\"headerlink\" title=\"1.2 快速恢复和快速重传\"></a>1.2 快速恢复和快速重传</h2><p>因此，个人理解，老版本上收到三个重复ack认为丢包，进入丢包处理，重置了拥塞窗口，在非重复ack到来后，拥塞窗口仍然需要从零开始指数上升，而对于快速恢复而言，其只进入拥塞避免阶段，拥塞窗口只是进行一定修正，在非重复ack到来后，仍然能根据阈值来决定是否执行非重启的慢启动，这时候恢复速度相较于严格的丢包处理快了不少。</p>\n<p>由于tcp对于丢包的容忍极低，一旦丢包发生，就会进入严格的拥塞处理，而RTO是丢包主要判断依据，因此快速重传也是针对tcp对于丢包容忍度低的一个修正，避免进入RTO，直接影响传输性能。</p>\n<h1 id=\"2-拥塞控制代码分析\"><a href=\"#2-拥塞控制代码分析\" class=\"headerlink\" title=\"2. 拥塞控制代码分析\"></a>2. 拥塞控制代码分析</h1><p>本章主要基于reno的拥塞控制。下文中的代码均基于linux kernel 2.6.32版本，直到linux kernel 4.9-rc8之前的版本，tcp整体并没有太大变化。本文不分析frto相关内容。</p>\n<h2 id=\"2-1-调用链\"><a href=\"#2-1-调用链\" class=\"headerlink\" title=\"2.1 调用链\"></a>2.1 调用链</h2><p>由于文档描述上是直接给出一个计算过程，如慢启动阶段的指数上升，和代码直观上看略有不同，因此这里需要先缕清楚整个的调用链，能更好的描述整个拥塞控制的过程。</p>\n<p>tcp的拥塞主要是基于定时器(RTO)和ack的，因此主要处理函数都以tcp_ack为起点。这里不分析整个tcp_ack函数，仅分析常规调用链。</p>\n<p>整体入口如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 当ack时一个可疑的ack，如sack，或者路由发送的显示拥塞控制，或者当前拥塞状态不是正常状态时。</span></div><div class=\"line\"><span class=\"keyword\">if</span> (tcp_ack_is_dubious(sk, flag)) &#123;</div><div class=\"line\">\t<span class=\"comment\">/* Advance CWND, if state allows this. */</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> ((flag &amp; FLAG_DATA_ACKED) &amp;&amp; !frto_cwnd &amp;&amp;</div><div class=\"line\">\t    tcp_may_raise_cwnd(sk, flag))</div><div class=\"line\">\t    <span class=\"comment\">// 当窗口仍然满足可以增长的条件时，进入拥塞控制，</span></div><div class=\"line\">\t    <span class=\"comment\">// 这是一个钩子函数，具体实现由具体拥塞控制算法来实现，</span></div><div class=\"line\">\t    <span class=\"comment\">// 对于reno而言可能是慢启动，可能是拥塞避免。</span></div><div class=\"line\">\t\ttcp_cong_avoid(sk, ack, prior_in_flight);</div><div class=\"line\">\t<span class=\"comment\">// 处理拥塞状态机，暂时不展开</span></div><div class=\"line\">\ttcp_fastretrans_alert(sk, prior_packets - tp-&gt;packets_out,</div><div class=\"line\">\t\t\t      flag);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 当这个ack是一个正常的数据确认包，进入拥塞控制</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> ((flag &amp; FLAG_DATA_ACKED) &amp;&amp; !frto_cwnd)</div><div class=\"line\">\t\ttcp_cong_avoid(sk, ack, prior_in_flight);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-tcp-reno的拥塞控制\"><a href=\"#2-2-tcp-reno的拥塞控制\" class=\"headerlink\" title=\"2.2 tcp reno的拥塞控制\"></a>2.2 tcp reno的拥塞控制</h2><p>tcp reno注册到拥塞控制框架中的是tcp_reno_cong_avoid函数。</p>\n<p>其代码较为简单，只是其中多了一部分tcp-abc的拥塞避免算法，其慢启动实现在tcp_slow_start中，可以参考[<a href=\"https://tools.ietf.org/html/rfc3465\" target=\"_blank\" rel=\"external\">rfc-3465</a>][<a href=\"http://blog.csdn.net/dog250/article/details/51348568\" target=\"_blank\" rel=\"external\">tcp_abc</a>]。大体是用已经确认的byte大小来作为拥塞控制的计算，在慢启动阶段会更加激进，但是可能会带来更大的burst。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * TCP Reno congestion control</div><div class=\"line\"> * This is special case used for fallback as well.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"comment\">/* This is Jacobson's slow start and congestion avoidance.</span></div><div class=\"line\"> * SIGCOMM '88, p. 328.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tcp_reno_cong_avoid</span><span class=\"params\">(<span class=\"keyword\">struct</span> sock *sk, u32 ack, u32 in_flight)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">struct</span> tcp_sock *tp = tcp_sk(sk);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span> (!tcp_is_cwnd_limited(sk, in_flight))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* In \"safe\" area, increase. */</span></div><div class=\"line\">\t<span class=\"comment\">// 小于阈值会进入慢启动环节，不重置窗口的慢启动。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh)</div><div class=\"line\">\t\ttcp_slow_start(tp);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* In dangerous area, increase slowly. */</span></div><div class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sysctl_tcp_abc) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">/* RFC3465: Appropriate Byte Count</span></div><div class=\"line\">\t\t * increase once for each full cwnd acked</div><div class=\"line\">\t\t */</div><div class=\"line\">\t\t<span class=\"comment\">// RFC3465的拥塞避免算法，使用bytes_acked来作为修改拥塞窗口的判断条件</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (tp-&gt;bytes_acked &gt;= tp-&gt;snd_cwnd*tp-&gt;mss_cache) &#123;</div><div class=\"line\">\t\t\ttp-&gt;bytes_acked -= tp-&gt;snd_cwnd*tp-&gt;mss_cache;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)</div><div class=\"line\">\t\t\t\ttp-&gt;snd_cwnd++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t    <span class=\"comment\">// 拥塞避免</span></div><div class=\"line\">\t\ttcp_cong_avoid_ai(tp, tp-&gt;snd_cwnd);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-3-慢启动\"><a href=\"#2-3-慢启动\" class=\"headerlink\" title=\"2.3 慢启动\"></a>2.3 慢启动</h2><p>慢启动里面额外涉及两篇rfc，<a href=\"https://tools.ietf.org/html/rfc3742\" target=\"_blank\" rel=\"external\">rfc-3742</a>和<a href=\"https://tools.ietf.org/html/rfc3465\" target=\"_blank\" rel=\"external\">tcp_abc</a>。</p>\n<p>其中snd_cwnd_cnt为线性增长器，只有当线性增长器大于一个窗口大小时，其才会将发送窗口增加，即其单位为1/snd_cwnd，后续还会在拥塞避免代码中见到。</p>\n<p>刚开始看代码时对下面那个循环并不是很理解，不理解为什么++是指数增长，直到放到整个调用栈上看，其具体流程如代码注释中所写，为指数增长的过程。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * Slow start is used when congestion window is less than slow start</div><div class=\"line\"> * threshold. This version implements the basic RFC2581 version</div><div class=\"line\"> * and optionally supports:</div><div class=\"line\"> * \tRFC3742 Limited Slow Start  \t  - growth limited to max_ssthresh</div><div class=\"line\"> *\tRFC3465 Appropriate Byte Counting - growth limited by bytes acknowledged</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tcp_slow_start</span><span class=\"params\">(<span class=\"keyword\">struct</span> tcp_sock *tp)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> cnt; <span class=\"comment\">/* increase in packets */</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* RFC3465: ABC Slow start</span></div><div class=\"line\">\t * Increase only after a full MSS of bytes is acked</div><div class=\"line\">\t *</div><div class=\"line\">\t * TCP sender SHOULD increase cwnd by the number of</div><div class=\"line\">\t * previously unacknowledged bytes ACKed by each incoming</div><div class=\"line\">\t * acknowledgment, provided the increase is not more than L</div><div class=\"line\">\t */</div><div class=\"line\">    <span class=\"comment\">// 不满足tcp abc的窗口增加条件，此时确认的字节数小于mss_cache。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (sysctl_tcp_abc &amp;&amp; tp-&gt;bytes_acked &lt; tp-&gt;mss_cache)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// RFC 3742，限制慢启动在一个RTT内的burst。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (sysctl_tcp_max_ssthresh &gt; <span class=\"number\">0</span> &amp;&amp; tp-&gt;snd_cwnd &gt; sysctl_tcp_max_ssthresh)</div><div class=\"line\">\t\tcnt = sysctl_tcp_max_ssthresh &gt;&gt; <span class=\"number\">1</span>;\t<span class=\"comment\">/* limited slow start */</span></div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t<span class=\"comment\">// 加上一个窗口大小，在没有abc的情况，保证在最底下的循环中拥塞窗口大小至少增加1.</span></div><div class=\"line\">\t\tcnt = tp-&gt;snd_cwnd;\t\t\t<span class=\"comment\">/* exponential increase */</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* RFC3465: ABC</span></div><div class=\"line\">\t * We MAY increase by 2 if discovered delayed ack</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"comment\">// tcp-abc，慢启动阶段更激进的burst。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (sysctl_tcp_abc &gt; <span class=\"number\">1</span> &amp;&amp; tp-&gt;bytes_acked &gt;= <span class=\"number\">2</span>*tp-&gt;mss_cache)</div><div class=\"line\">\t\tcnt &lt;&lt;= <span class=\"number\">1</span>;</div><div class=\"line\">\ttp-&gt;bytes_acked = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 更新snd_cwnd_cnt(窗口线性增长器)</span></div><div class=\"line\">    tp-&gt;snd_cwnd_cnt += cnt;</div><div class=\"line\">    <span class=\"comment\">// 线性增长器是窗口的多少倍，窗口就增加多少。</span></div><div class=\"line\">    <span class=\"comment\">// 注意：这里的标准场景下的线性增长，每次也只增长1个窗口大小，</span></div><div class=\"line\">    <span class=\"comment\">// 但是其仍然是指数增长，因此每个窗口发出去的数据对应一个ack，</span></div><div class=\"line\">    <span class=\"comment\">// 而每一个ack都会对应触发一次增长。</span></div><div class=\"line\">    <span class=\"comment\">// 以下为一个简单的例子，sender为发送端，receiver为接收端</span></div><div class=\"line\">    <span class=\"comment\">// px为包号为x的包，ack x为对第x个包的确认</span></div><div class=\"line\">    <span class=\"comment\">// snd_cwnd为拥塞窗口</span></div><div class=\"line\">    <span class=\"comment\">// sender                                           receiver</span></div><div class=\"line\">    <span class=\"comment\">//  p1 (snd_cwnd 1)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//    </span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 1</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (2)</span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">//  p2 (snd_cwnd 2)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//  p3 (snd_cwnd 2)  ---------------------------&gt; </span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 2</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (3)</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 3</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (4)</span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">//  p4 (snd_cwnd 4)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//  p5 (snd_cwnd 4)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//  p6 (snd_cwnd 4)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//  p7 (snd_cwnd 4)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 4</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (5)</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 5</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (6)</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 6</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (7)</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 7</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (8)</span></div><div class=\"line\">    <span class=\"comment\">//  send with snd_cwnd = 8 (p8 - p15)</span></div><div class=\"line\">    <span class=\"comment\">// 每一个ack对应增加一个窗口大小，不丢包的场景下相当于窗口以指数上升</span></div><div class=\"line\">    <span class=\"comment\">// 1 --&gt; 2 --&gt; 4 --&gt; 8</span></div><div class=\"line\">\t<span class=\"keyword\">while</span> (tp-&gt;snd_cwnd_cnt &gt;= tp-&gt;snd_cwnd) &#123;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd_cnt -= tp-&gt;snd_cwnd;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)</div><div class=\"line\">\t\t\ttp-&gt;snd_cwnd++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-4-拥塞避免\"><a href=\"#2-4-拥塞避免\" class=\"headerlink\" title=\"2.4 拥塞避免\"></a>2.4 拥塞避免</h2><p>拥塞避免的代码比较简短，注意2.3中所写的，snd_cwnd_cnt为线性增长器，其单位为1 / w。在reno调用中，这里的w也为snd_cwnd窗口大小。即每一个ack只增加1 / snd_\\cwnd大小的窗口。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* In theory this is tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd (or alternative w) */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tcp_cong_avoid_ai</span><span class=\"params\">(<span class=\"keyword\">struct</span> tcp_sock *tp, u32 w)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// 每次cnt++，直到w次后snd_cwnd++，即单位 1 / w</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd_cnt &gt;= w) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)</div><div class=\"line\">\t\t\ttp-&gt;snd_cwnd++;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd_cnt = <span class=\"number\">0</span>;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd_cnt++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-kernel-4-9的改变\"><a href=\"#3-kernel-4-9的改变\" class=\"headerlink\" title=\"3. kernel 4.9的改变\"></a>3. kernel 4.9的改变</h1><p>对tcp_slow_start的改动不算是4.9的，早在3.18之前就已经改变了，使用的已经不是之前的snd_cwnd_cnt，而是采用tcp-abc算法来进行慢启动。</p>\n<p>慢启动仍然使用类似tcp-abc的实现机制，不过其并不以byte作为单位，而是以MSS作为单位进行处理。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Slow start is used when congestion window is no greater than the slow start</span></div><div class=\"line\"> * threshold. We base on RFC2581 and also handle stretch ACKs properly.</div><div class=\"line\"> * We do not implement RFC3465 Appropriate Byte Counting (ABC) per se but</div><div class=\"line\"> * something better;) a packet is only considered (s)acked in its entirety to</div><div class=\"line\"> * defend the ACK attacks described in the RFC. Slow start processes a stretch</div><div class=\"line\"> * ACK of degree N as if N acks of degree 1 are received back to back except</div><div class=\"line\"> * ABC caps N to 2. Slow start exits when cwnd grows over ssthresh and</div><div class=\"line\"> * returns the leftover acks to adjust cwnd in congestion avoidance mode.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\">u32 <span class=\"title\">tcp_slow_start</span><span class=\"params\">(<span class=\"keyword\">struct</span> tcp_sock *tp, u32 acked)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// 使用确认的包数(其中可能包括sack的确认，或者重传数据的确认都加上)</span></div><div class=\"line\">    <span class=\"comment\">// 来更新窗口值，而不是之前的byte。</span></div><div class=\"line\">    <span class=\"comment\">// 在函数tcp_clean_rtx_queue中有更新对应的delivered。</span></div><div class=\"line\">    <span class=\"comment\">// 其更新的值貌似和MSS有关系。</span></div><div class=\"line\">\tu32 cwnd = min(tp-&gt;snd_cwnd + acked, tp-&gt;snd_ssthresh);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 当acked仍然有值，说明超过阈值，处理完slow start后还会进行congestion avoid的处理。</span></div><div class=\"line\">\tacked -= cwnd - tp-&gt;snd_cwnd;</div><div class=\"line\">\ttp-&gt;snd_cwnd = min(cwnd, tp-&gt;snd_cwnd_clamp);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> acked;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>拥塞避免上和老版本类似，也使用到了线性增长器，但是涨幅比之前版本较大，并不是以1为计数，而是以acked，即已经确认的MSS个数据片作为单位。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* In theory this is tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd (or alternative w),</span></div><div class=\"line\"> * for every packet that was ACKed.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tcp_cong_avoid_ai</span><span class=\"params\">(<span class=\"keyword\">struct</span> tcp_sock *tp, u32 w, u32 acked)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">/* If credits accumulated at a higher w, apply them gently now. */</span></div><div class=\"line\">\t<span class=\"comment\">// 第一次线性增长计算。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd_cnt &gt;= w) &#123;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd_cnt = <span class=\"number\">0</span>;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd++;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 以 acked / snd_cwnd为单位增长。将循环改为除法。</span></div><div class=\"line\">\ttp-&gt;snd_cwnd_cnt += acked;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd_cnt &gt;= w) &#123;</div><div class=\"line\">\t\tu32 delta = tp-&gt;snd_cwnd_cnt / w;</div><div class=\"line\"></div><div class=\"line\">\t\ttp-&gt;snd_cwnd_cnt -= delta * w;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd += delta;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\ttp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tp-&gt;snd_cwnd_clamp);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>@小刘<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">悦</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>@(Network)[tcp, 慢启动]</p>\n<h1 id=\"TCP拥塞控制两个速率增长阶段分析\"><a href=\"#TCP拥塞控制两个速率增长阶段分析\" class=\"headerlink\" title=\"TCP拥塞控制两个速率增长阶段分析\"></a>TCP拥塞控制两个速率增长阶段分析</h1><h1 id=\"0-参考文档\"><a href=\"#0-参考文档\" class=\"headerlink\" title=\"0. 参考文档\"></a>0. 参考文档</h1><p>[1] <a href=\"https://tools.ietf.org/html/rfc5681\">rfc-5681</a><br>[2] <a href=\"http://blog.csdn.net/dog250/article/details/51348568\">tcp-abc-rfc</a><br>[3] <a href=\"https://tools.ietf.org/html/rfc3465\">rfc-3465</a><br>[4] <a href=\"https://tools.ietf.org/html/rfc3742\">rfc-3742</a></p>\n<h1 id=\"1-拥塞控制个人理解\"><a href=\"#1-拥塞控制个人理解\" class=\"headerlink\" title=\"1. 拥塞控制个人理解\"></a>1. 拥塞控制个人理解</h1><h2 id=\"1-1-慢启动与拥塞避免\"><a href=\"#1-1-慢启动与拥塞避免\" class=\"headerlink\" title=\"1.1 慢启动与拥塞避免\"></a>1.1 慢启动与拥塞避免</h2><p>慢启动和拥塞避免，主要是用于拥塞控制中拥塞窗口增长的维护。</p>\n<p>根据阈值，拥塞控制其实分为两部分，小于阈值的慢启动阶段，大于阈值进入拥塞避免阶段。</p>\n<p>慢启动作为拥塞控制的一部分，我觉得其名字取的比较具有混淆性。个人理解的慢启动分为两种，一种是拥塞窗口小于阈值时候正常的一个指数增长的过程，这个过程中的拥塞窗口不会重置，会持续增长，还有一种是与快速恢复对应的慢启动重新启动，这种时候会将拥塞窗口重置为1，并重新开始指数增长。这么理解的原因如下：</p>\n<p>在<a href=\"https://tools.ietf.org/html/rfc5681\">文档</a>中描述快速恢复时，当收到三个重复ack时候，这时候可能并不是实际丢包，可能是因为链路问题，较晚到达接收端。</p>\n<ul>\n<li>在BSD 4.3之前会进入慢启动阶段，但是理论上慢启动一般是指数上升的过程，反而是拥塞避免阶段线性上升速度较慢，且拥塞避免会更新当前的拥塞窗口和阈值，会出现小范围衰减。</li>\n<li>假如tcp认为当前包丢失，会很严格的重置拥塞窗口(具体代码如rto触发tcp_enter_loss)，这时候速率曲线不会只是单纯减低到某个值，而是会降低到零点。</li>\n</ul>\n<h2 id=\"1-2-快速恢复和快速重传\"><a href=\"#1-2-快速恢复和快速重传\" class=\"headerlink\" title=\"1.2 快速恢复和快速重传\"></a>1.2 快速恢复和快速重传</h2><p>因此，个人理解，老版本上收到三个重复ack认为丢包，进入丢包处理，重置了拥塞窗口，在非重复ack到来后，拥塞窗口仍然需要从零开始指数上升，而对于快速恢复而言，其只进入拥塞避免阶段，拥塞窗口只是进行一定修正，在非重复ack到来后，仍然能根据阈值来决定是否执行非重启的慢启动，这时候恢复速度相较于严格的丢包处理快了不少。</p>\n<p>由于tcp对于丢包的容忍极低，一旦丢包发生，就会进入严格的拥塞处理，而RTO是丢包主要判断依据，因此快速重传也是针对tcp对于丢包容忍度低的一个修正，避免进入RTO，直接影响传输性能。</p>\n<h1 id=\"2-拥塞控制代码分析\"><a href=\"#2-拥塞控制代码分析\" class=\"headerlink\" title=\"2. 拥塞控制代码分析\"></a>2. 拥塞控制代码分析</h1><p>本章主要基于reno的拥塞控制。下文中的代码均基于linux kernel 2.6.32版本，直到linux kernel 4.9-rc8之前的版本，tcp整体并没有太大变化。本文不分析frto相关内容。</p>\n<h2 id=\"2-1-调用链\"><a href=\"#2-1-调用链\" class=\"headerlink\" title=\"2.1 调用链\"></a>2.1 调用链</h2><p>由于文档描述上是直接给出一个计算过程，如慢启动阶段的指数上升，和代码直观上看略有不同，因此这里需要先缕清楚整个的调用链，能更好的描述整个拥塞控制的过程。</p>\n<p>tcp的拥塞主要是基于定时器(RTO)和ack的，因此主要处理函数都以tcp_ack为起点。这里不分析整个tcp_ack函数，仅分析常规调用链。</p>\n<p>整体入口如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 当ack时一个可疑的ack，如sack，或者路由发送的显示拥塞控制，或者当前拥塞状态不是正常状态时。</span></div><div class=\"line\"><span class=\"keyword\">if</span> (tcp_ack_is_dubious(sk, flag)) &#123;</div><div class=\"line\">\t<span class=\"comment\">/* Advance CWND, if state allows this. */</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> ((flag &amp; FLAG_DATA_ACKED) &amp;&amp; !frto_cwnd &amp;&amp;</div><div class=\"line\">\t    tcp_may_raise_cwnd(sk, flag))</div><div class=\"line\">\t    <span class=\"comment\">// 当窗口仍然满足可以增长的条件时，进入拥塞控制，</span></div><div class=\"line\">\t    <span class=\"comment\">// 这是一个钩子函数，具体实现由具体拥塞控制算法来实现，</span></div><div class=\"line\">\t    <span class=\"comment\">// 对于reno而言可能是慢启动，可能是拥塞避免。</span></div><div class=\"line\">\t\ttcp_cong_avoid(sk, ack, prior_in_flight);</div><div class=\"line\">\t<span class=\"comment\">// 处理拥塞状态机，暂时不展开</span></div><div class=\"line\">\ttcp_fastretrans_alert(sk, prior_packets - tp-&gt;packets_out,</div><div class=\"line\">\t\t\t      flag);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 当这个ack是一个正常的数据确认包，进入拥塞控制</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> ((flag &amp; FLAG_DATA_ACKED) &amp;&amp; !frto_cwnd)</div><div class=\"line\">\t\ttcp_cong_avoid(sk, ack, prior_in_flight);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-tcp-reno的拥塞控制\"><a href=\"#2-2-tcp-reno的拥塞控制\" class=\"headerlink\" title=\"2.2 tcp reno的拥塞控制\"></a>2.2 tcp reno的拥塞控制</h2><p>tcp reno注册到拥塞控制框架中的是tcp_reno_cong_avoid函数。</p>\n<p>其代码较为简单，只是其中多了一部分tcp-abc的拥塞避免算法，其慢启动实现在tcp_slow_start中，可以参考[<a href=\"https://tools.ietf.org/html/rfc3465\">rfc-3465</a>][<a href=\"http://blog.csdn.net/dog250/article/details/51348568\">tcp_abc</a>]。大体是用已经确认的byte大小来作为拥塞控制的计算，在慢启动阶段会更加激进，但是可能会带来更大的burst。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> * TCP Reno congestion control</div><div class=\"line\"> * This is special case used for fallback as well.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"comment\">/* This is Jacobson's slow start and congestion avoidance.</div><div class=\"line\"> * SIGCOMM '88, p. 328.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tcp_reno_cong_avoid</span><span class=\"params\">(<span class=\"keyword\">struct</span> sock *sk, u32 ack, u32 in_flight)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">struct</span> tcp_sock *tp = tcp_sk(sk);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span> (!tcp_is_cwnd_limited(sk, in_flight))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* In \"safe\" area, increase. */</span></div><div class=\"line\">\t<span class=\"comment\">// 小于阈值会进入慢启动环节，不重置窗口的慢启动。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh)</div><div class=\"line\">\t\ttcp_slow_start(tp);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* In dangerous area, increase slowly. */</span></div><div class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sysctl_tcp_abc) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">/* RFC3465: Appropriate Byte Count</div><div class=\"line\">\t\t * increase once for each full cwnd acked</div><div class=\"line\">\t\t */</span></div><div class=\"line\">\t\t<span class=\"comment\">// RFC3465的拥塞避免算法，使用bytes_acked来作为修改拥塞窗口的判断条件</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (tp-&gt;bytes_acked &gt;= tp-&gt;snd_cwnd*tp-&gt;mss_cache) &#123;</div><div class=\"line\">\t\t\ttp-&gt;bytes_acked -= tp-&gt;snd_cwnd*tp-&gt;mss_cache;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)</div><div class=\"line\">\t\t\t\ttp-&gt;snd_cwnd++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t    <span class=\"comment\">// 拥塞避免</span></div><div class=\"line\">\t\ttcp_cong_avoid_ai(tp, tp-&gt;snd_cwnd);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-3-慢启动\"><a href=\"#2-3-慢启动\" class=\"headerlink\" title=\"2.3 慢启动\"></a>2.3 慢启动</h2><p>慢启动里面额外涉及两篇rfc，<a href=\"https://tools.ietf.org/html/rfc3742\">rfc-3742</a>和<a href=\"https://tools.ietf.org/html/rfc3465\">tcp_abc</a>。</p>\n<p>其中snd_cwnd_cnt为线性增长器，只有当线性增长器大于一个窗口大小时，其才会将发送窗口增加，即其单位为1/snd_cwnd，后续还会在拥塞避免代码中见到。</p>\n<p>刚开始看代码时对下面那个循环并不是很理解，不理解为什么++是指数增长，直到放到整个调用栈上看，其具体流程如代码注释中所写，为指数增长的过程。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> * Slow start is used when congestion window is less than slow start</div><div class=\"line\"> * threshold. This version implements the basic RFC2581 version</div><div class=\"line\"> * and optionally supports:</div><div class=\"line\"> * \tRFC3742 Limited Slow Start  \t  - growth limited to max_ssthresh</div><div class=\"line\"> *\tRFC3465 Appropriate Byte Counting - growth limited by bytes acknowledged</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tcp_slow_start</span><span class=\"params\">(<span class=\"keyword\">struct</span> tcp_sock *tp)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> cnt; <span class=\"comment\">/* increase in packets */</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* RFC3465: ABC Slow start</div><div class=\"line\">\t * Increase only after a full MSS of bytes is acked</div><div class=\"line\">\t *</div><div class=\"line\">\t * TCP sender SHOULD increase cwnd by the number of</div><div class=\"line\">\t * previously unacknowledged bytes ACKed by each incoming</div><div class=\"line\">\t * acknowledgment, provided the increase is not more than L</div><div class=\"line\">\t */</span></div><div class=\"line\">    <span class=\"comment\">// 不满足tcp abc的窗口增加条件，此时确认的字节数小于mss_cache。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (sysctl_tcp_abc &amp;&amp; tp-&gt;bytes_acked &lt; tp-&gt;mss_cache)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// RFC 3742，限制慢启动在一个RTT内的burst。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (sysctl_tcp_max_ssthresh &gt; <span class=\"number\">0</span> &amp;&amp; tp-&gt;snd_cwnd &gt; sysctl_tcp_max_ssthresh)</div><div class=\"line\">\t\tcnt = sysctl_tcp_max_ssthresh &gt;&gt; <span class=\"number\">1</span>;\t<span class=\"comment\">/* limited slow start */</span></div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t<span class=\"comment\">// 加上一个窗口大小，在没有abc的情况，保证在最底下的循环中拥塞窗口大小至少增加1.</span></div><div class=\"line\">\t\tcnt = tp-&gt;snd_cwnd;\t\t\t<span class=\"comment\">/* exponential increase */</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* RFC3465: ABC</div><div class=\"line\">\t * We MAY increase by 2 if discovered delayed ack</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"comment\">// tcp-abc，慢启动阶段更激进的burst。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (sysctl_tcp_abc &gt; <span class=\"number\">1</span> &amp;&amp; tp-&gt;bytes_acked &gt;= <span class=\"number\">2</span>*tp-&gt;mss_cache)</div><div class=\"line\">\t\tcnt &lt;&lt;= <span class=\"number\">1</span>;</div><div class=\"line\">\ttp-&gt;bytes_acked = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 更新snd_cwnd_cnt(窗口线性增长器)</span></div><div class=\"line\">    tp-&gt;snd_cwnd_cnt += cnt;</div><div class=\"line\">    <span class=\"comment\">// 线性增长器是窗口的多少倍，窗口就增加多少。</span></div><div class=\"line\">    <span class=\"comment\">// 注意：这里的标准场景下的线性增长，每次也只增长1个窗口大小，</span></div><div class=\"line\">    <span class=\"comment\">// 但是其仍然是指数增长，因此每个窗口发出去的数据对应一个ack，</span></div><div class=\"line\">    <span class=\"comment\">// 而每一个ack都会对应触发一次增长。</span></div><div class=\"line\">    <span class=\"comment\">// 以下为一个简单的例子，sender为发送端，receiver为接收端</span></div><div class=\"line\">    <span class=\"comment\">// px为包号为x的包，ack x为对第x个包的确认</span></div><div class=\"line\">    <span class=\"comment\">// snd_cwnd为拥塞窗口</span></div><div class=\"line\">    <span class=\"comment\">// sender                                           receiver</span></div><div class=\"line\">    <span class=\"comment\">//  p1 (snd_cwnd 1)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//    </span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 1</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (2)</span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">//  p2 (snd_cwnd 2)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//  p3 (snd_cwnd 2)  ---------------------------&gt; </span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 2</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (3)</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 3</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (4)</span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">//  p4 (snd_cwnd 4)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//  p5 (snd_cwnd 4)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//  p6 (snd_cwnd 4)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//  p7 (snd_cwnd 4)  ---------------------------&gt;</span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 4</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (5)</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 5</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (6)</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 6</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (7)</span></div><div class=\"line\">    <span class=\"comment\">//                   &lt;---------------------------     ack 7</span></div><div class=\"line\">    <span class=\"comment\">//  snd_cwnd++ (8)</span></div><div class=\"line\">    <span class=\"comment\">//  send with snd_cwnd = 8 (p8 - p15)</span></div><div class=\"line\">    <span class=\"comment\">// 每一个ack对应增加一个窗口大小，不丢包的场景下相当于窗口以指数上升</span></div><div class=\"line\">    <span class=\"comment\">// 1 --&gt; 2 --&gt; 4 --&gt; 8</span></div><div class=\"line\">\t<span class=\"keyword\">while</span> (tp-&gt;snd_cwnd_cnt &gt;= tp-&gt;snd_cwnd) &#123;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd_cnt -= tp-&gt;snd_cwnd;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)</div><div class=\"line\">\t\t\ttp-&gt;snd_cwnd++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-4-拥塞避免\"><a href=\"#2-4-拥塞避免\" class=\"headerlink\" title=\"2.4 拥塞避免\"></a>2.4 拥塞避免</h2><p>拥塞避免的代码比较简短，注意2.3中所写的，snd_cwnd_cnt为线性增长器，其单位为1 / w。在reno调用中，这里的w也为snd_cwnd窗口大小。即每一个ack只增加1 / snd_\\cwnd大小的窗口。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* In theory this is tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd (or alternative w) */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tcp_cong_avoid_ai</span><span class=\"params\">(<span class=\"keyword\">struct</span> tcp_sock *tp, u32 w)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 每次cnt++，直到w次后snd_cwnd++，即单位 1 / w</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd_cnt &gt;= w) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)</div><div class=\"line\">\t\t\ttp-&gt;snd_cwnd++;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd_cnt = <span class=\"number\">0</span>;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd_cnt++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-kernel-4-9的改变\"><a href=\"#3-kernel-4-9的改变\" class=\"headerlink\" title=\"3. kernel 4.9的改变\"></a>3. kernel 4.9的改变</h1><p>对tcp_slow_start的改动不算是4.9的，早在3.18之前就已经改变了，使用的已经不是之前的snd_cwnd_cnt，而是采用tcp-abc算法来进行慢启动。</p>\n<p>慢启动仍然使用类似tcp-abc的实现机制，不过其并不以byte作为单位，而是以MSS作为单位进行处理。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Slow start is used when congestion window is no greater than the slow start</div><div class=\"line\"> * threshold. We base on RFC2581 and also handle stretch ACKs properly.</div><div class=\"line\"> * We do not implement RFC3465 Appropriate Byte Counting (ABC) per se but</div><div class=\"line\"> * something better;) a packet is only considered (s)acked in its entirety to</div><div class=\"line\"> * defend the ACK attacks described in the RFC. Slow start processes a stretch</div><div class=\"line\"> * ACK of degree N as if N acks of degree 1 are received back to back except</div><div class=\"line\"> * ABC caps N to 2. Slow start exits when cwnd grows over ssthresh and</div><div class=\"line\"> * returns the leftover acks to adjust cwnd in congestion avoidance mode.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\">u32 <span class=\"title\">tcp_slow_start</span><span class=\"params\">(<span class=\"keyword\">struct</span> tcp_sock *tp, u32 acked)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 使用确认的包数(其中可能包括sack的确认，或者重传数据的确认都加上)</span></div><div class=\"line\">    <span class=\"comment\">// 来更新窗口值，而不是之前的byte。</span></div><div class=\"line\">    <span class=\"comment\">// 在函数tcp_clean_rtx_queue中有更新对应的delivered。</span></div><div class=\"line\">    <span class=\"comment\">// 其更新的值貌似和MSS有关系。</span></div><div class=\"line\">\tu32 cwnd = min(tp-&gt;snd_cwnd + acked, tp-&gt;snd_ssthresh);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 当acked仍然有值，说明超过阈值，处理完slow start后还会进行congestion avoid的处理。</span></div><div class=\"line\">\tacked -= cwnd - tp-&gt;snd_cwnd;</div><div class=\"line\">\ttp-&gt;snd_cwnd = min(cwnd, tp-&gt;snd_cwnd_clamp);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> acked;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>拥塞避免上和老版本类似，也使用到了线性增长器，但是涨幅比之前版本较大，并不是以1为计数，而是以acked，即已经确认的MSS个数据片作为单位。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* In theory this is tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd (or alternative w),</div><div class=\"line\"> * for every packet that was ACKed.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tcp_cong_avoid_ai</span><span class=\"params\">(<span class=\"keyword\">struct</span> tcp_sock *tp, u32 w, u32 acked)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">/* If credits accumulated at a higher w, apply them gently now. */</span></div><div class=\"line\">\t<span class=\"comment\">// 第一次线性增长计算。</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd_cnt &gt;= w) &#123;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd_cnt = <span class=\"number\">0</span>;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd++;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 以 acked / snd_cwnd为单位增长。将循环改为除法。</span></div><div class=\"line\">\ttp-&gt;snd_cwnd_cnt += acked;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (tp-&gt;snd_cwnd_cnt &gt;= w) &#123;</div><div class=\"line\">\t\tu32 delta = tp-&gt;snd_cwnd_cnt / w;</div><div class=\"line\"></div><div class=\"line\">\t\ttp-&gt;snd_cwnd_cnt -= delta * w;</div><div class=\"line\">\t\ttp-&gt;snd_cwnd += delta;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\ttp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tp-&gt;snd_cwnd_clamp);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>@小刘<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">悦</div></pre></td></tr></table></figure></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj2gzs4jb0000r8c3adjey83v","tag_id":"cj2gzs4jn0004r8c3zytmjcnw","_id":"cj2gzs4k2000cr8c3fg83mlmy"},{"post_id":"cj2gzs4jb0000r8c3adjey83v","tag_id":"cj2gzs4jx0008r8c30li1532m","_id":"cj2gzs4k2000dr8c30q8wbp5c"},{"post_id":"cj2gzs4jq0005r8c39mlsqsyu","tag_id":"cj2gzs4k1000br8c3yqug5hiz","_id":"cj2gzs4k4000hr8c3pyr30igi"},{"post_id":"cj2gzs4jq0005r8c39mlsqsyu","tag_id":"cj2gzs4k2000er8c33xov2te0","_id":"cj2gzs4k4000ir8c38fv90lwg"},{"post_id":"cj2gzs4jq0005r8c39mlsqsyu","tag_id":"cj2gzs4k3000fr8c343sx5pfz","_id":"cj2gzs4k5000kr8c37dvmb2s1"},{"post_id":"cj2gzs4jt0006r8c3tgsnlifo","tag_id":"cj2gzs4k1000br8c3yqug5hiz","_id":"cj2gzs4k6000or8c3zyo6b35l"},{"post_id":"cj2gzs4jt0006r8c3tgsnlifo","tag_id":"cj2gzs4k2000er8c33xov2te0","_id":"cj2gzs4k6000pr8c37zz8iwpz"},{"post_id":"cj2gzs4jt0006r8c3tgsnlifo","tag_id":"cj2gzs4k5000lr8c3vcigmqxy","_id":"cj2gzs4k8000rr8c3n74x4tlo"},{"post_id":"cj2gzs4jt0006r8c3tgsnlifo","tag_id":"cj2gzs4k3000fr8c343sx5pfz","_id":"cj2gzs4k8000sr8c3j2tcli8f"},{"post_id":"cj2gzs4jv0007r8c3wxppvvaw","tag_id":"cj2gzs4k6000nr8c3wajxtt1b","_id":"cj2gzs4k9000ur8c3k485fm68"},{"post_id":"cj2gzs4jz0009r8c36a3sonnp","tag_id":"cj2gzs4k7000qr8c3vrp7nntg","_id":"cj2gzs4ka000wr8c3vl25v7yl"},{"post_id":"cj2gzs4jz0009r8c36a3sonnp","tag_id":"cj2gzs4k9000tr8c3iq31n6uh","_id":"cj2gzs4ka000xr8c3jgxn7wrg"},{"post_id":"cj2gzs4k0000ar8c35zl4e115","tag_id":"cj2gzs4k1000br8c3yqug5hiz","_id":"cj2gzs4kd0010r8c3caonfflj"},{"post_id":"cj2gzs4k0000ar8c35zl4e115","tag_id":"cj2gzs4k2000er8c33xov2te0","_id":"cj2gzs4kd0011r8c3drlhmvk9"},{"post_id":"cj2gzs4k0000ar8c35zl4e115","tag_id":"cj2gzs4k3000fr8c343sx5pfz","_id":"cj2gzs4kd0012r8c3i2msywrw"}],"Tag":[{"name":"QUIC","_id":"cj2gzs4jn0004r8c3zytmjcnw"},{"name":"传输协议","_id":"cj2gzs4jx0008r8c30li1532m"},{"name":"TCP","_id":"cj2gzs4k1000br8c3yqug5hiz"},{"name":"linux","_id":"cj2gzs4k2000er8c33xov2te0"},{"name":"拥塞控制","_id":"cj2gzs4k3000fr8c343sx5pfz"},{"name":"读书笔记","_id":"cj2gzs4k5000lr8c3vcigmqxy"},{"name":"webrt","_id":"cj2gzs4k6000nr8c3wajxtt1b"},{"name":"涛哥说的都怼","_id":"cj2gzs4k7000qr8c3vrp7nntg"},{"name":"fun","_id":"cj2gzs4k9000tr8c3iq31n6uh"}]}}